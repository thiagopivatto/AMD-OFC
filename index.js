/*============â‰ â‰ ==========â‰ â‰ =============\\


NÃƒO PASSE O BOT PARA NINGUÃ‰M, MUITOS VÃƒO FINGIR SER AMIGO. 

MUITOS DESEJAM COMPRAR PARA REVENDER E DIZER QUE FEZ.. 

EU ALEATORY NÃƒO FIZ TUDO, ASSUMO ISSO, PRECISEI DE AJUDA

PRA ISSO TENHO AMIGOS, PRA EVOLUIR JUNTO, ENTÃƒO.. 

NÃƒO JOGUE O ESFORÃ‡O QUE TIVE, APESAR DE NÃƒO SER TANTO A 

VISTA DE QUEM JÃ CONHECE O BASTANTE DA ÃREA.. 


//=======================================*/

const { default: makeWASocket, downloadContentFromMessage, fetchLatestBaileysVersion, useSingleFileAuthState, makeInMemoryStore, DisconnectReason, WAGroupMetadata, relayWAMessage,	MediaPathMap, mentionedJid, processTime, MediaType, Browser, MessageType, Presence, Mimetype, Browsers, delay 
} = require('@adiwajshing/baileys');

//_-_-_-_-_-_-_-_-_-_-MODULOS/FUNÃ‡Ã•ES-_-_-_-_-_-_-_-_-_-_-_-\\

const { hx, fs, Boom, axios, chalk, yts, crypto, util, P, encodeUrl, linkfy, request, cheerio, ms, ffmpeg, imgbb, googleImage, googleIt, fetch, imageToBase64, webp2gifFile, webp_mp4, EmojiAPI, qrterminal, emoji, exec, spawn, execSync, moment, color, time, hora, date, getBuffer, convertSticker, recognize, fetchJson, fetchText, getBase64, createExif, insert, response, addLimit, getLimit, mediafireDl, upload, nit, addBanned, unBanned, BannedExpired, cekBannedUser, isFiltered, addFilter, validmove, setGame, addComandosId, deleteComandos, getComandoBlock, getComandos, addComandos, palavrasANA, quizanime, quizanimais, getLevelingXp, getLevelingLevel, getLevelingId, addLevelingXp, addLevelingLevel, addLevelingId, bayarLimit, limitAdd, addATM, addKoinUser, checkATMuser, getRegisteredRandomId, addRegisteredUser, createSerial, checkRegisteredUser, confirmATM, runtime, getpc, supre, WinnerX, WinnerO, Tie, IA, IAmove1, IAalter, priorityC, addTTTId, addTTTwin, addTTTdefeat, addTTTtie, addTTTpoints, getTTTId, getTTTwins, getTTTdefeats, getTTTties, getTTTpoints, wait, getExtension, h2k, generateMessageID, getGroupAdmins, getRandom, banner2, banner3, infopd, success, start, close, temporizador, cmdadd, addMetadata, chyt, ttthelp, tttme, tttset, esp, kyun, simih } = require('./consts-func.js')

//-_-_-_-_-_-_-_-_-_-_--_-JSON-FUNÃ‡Ã•ES-_-_-_-_-_-_-_-_-_-_-_-_\\

const { adeuscara, welcome_group, welcome_group2, bye_group, bye_group2, voting, sotoy, addVote, delVote, countMessage, comandos, welkom2, modobn, nsfw, daily, nescessario, welkom, premium, limitefll, antiflood, samih, samih2, _leveling, _level, bancht, anticall, ban, afk, joguinhodavelhajs, joguinhodavelhajs2, setting, logoslink, antilink, antifake, antilinkhard, antilinkgp, antiimg, antisticker, antinotas, antictt, anticatalogo, antidoc, antiloc, antipv, antivid, antiaudio, palavra, palavrao, store, state, saveState } = require('./consts-func.js')

//-_-_-_-_-_-_-_-_-_-_-JS-MENUS/INFORMAÃ‡Ã•ES-_-_-_-_-_-_-_-_-_-_\\

const { menu, menudono, adms, menulogos, efeitos, menuprem, brincadeiras ,infovotacao, infocontador, infobemvindo, infolistanegra, infopalavrao, infobancarac, infodono, gitdobot, configbot, hospedar, cmd_termux, alteradores, destrava, destrava2, tabela, conselhob, palavras } = require('./consts-func.js')

//_-_-_-_-_-_-_-_-_-_-_-_-(INFOS)_-_-_-_-_-_-_-_-_-_-_-_-_-_-_--\\

const { prefix, NomeDoBot, NickDono, numerodono } = require("./dono/settings.json")

const { linklogos, crtt, cdd, forwarding, imgnazista, verificado, gifmenu, imggay, imgcorno, imggostosa, imggostoso, imgfeio, imgvesgo, imgbebado, imggado, fundo1, fundo2, banChats, dono2, dono3, dono4, dono5, tapacmd, matarcmd, beijocmd, chutecmd} = require("./dono/nescessario.json")

//====================â‰ â‰ ===============\\

logo = logoslink.logo

limitefl = limitefll.limitefl

offline = false

numbernye = '0'

blocked = [] 

hitt = []

alekey = 'ale652'

keyale = "key-thiago-pivatto-2.0"

//=====================================\\


async function startAle() {

// ABAIXO: INÃCIO DE CONEXÃƒO

const { version, isLatest } = await fetchLatestBaileysVersion()
console.log(`usando WA v${version.join('.')}, Ã© mais recente: ${isLatest}`)
  
console.log(banner3.string)   
console.log(banner2.string)
const conn = makeWASocket({
version,  
logger: P({ level: 'fatal' }),
printQRInTerminal: true,
auth: state
})

store.bind(conn.ev)

conn.ev.on('chats.set', () => {
//pode usar "store.chats" como quiser, mesmo depois que o soquete morre
// "chats" => uma instÃ¢ncia keyedDB
console.log('Tem conversas', store.chats.all())
})

conn.ev.on('contacts.set', () => {
console.log('Tem contatos', Object.values(store.contacts))
})

//===============(BEM VINDO)=============\\


conn.ev.on('group-participants.update', async (ale) => {
  
const groupMetadata = await conn.groupMetadata(ale.id) 
  
const mdata = await conn.groupMetadata(ale.id)  


// CONST DO CMD DE BANIR QUEM ESTIVER NA LISTA N

const dbackid = []
for(i=0;i<adeuscara.length;++i) dbackid.push(adeuscara[i].groupId)
console.log(ale)
if(dbackid.indexOf(ale.id) >= 0) {
if (ale.action == 'add'){ 
num = ale.participants[0]
var ind = dbackid.indexOf(ale.id)
if(adeuscara[ind].actived && adeuscara[ind].number.indexOf(num.split('@')[0]) >= 0) {
await conn.sendMessage(mdata.id,{text: '*Olha quem deu as cara por aqui, sente o poder do ban cabaÃ§o*'})
conn.groupParticipantsUpdate(mdata.id, [ale.participants[0]], 'remove')
return
}
}
}

// FIM LISTANEGRA CONST ^


// ANTIFAKE QUE ESTÃ JUNTO COM BEM VINDO 

if(antifake.includes(ale.id)) {
if (ale.action === 'add' && !ale.participants[0].startsWith(55)){
num = ale.participants[0]
conn.sendMessage(mdata.id, {text: ' â›¹ï¸â›¹ï¸Bye Bye Estrangeiro...ğŸ‘‹ğŸŒï¸'})
await delay(1000)
conn.groupParticipantsUpdate(mdata.id, [ale.participants[0]], 'remove')
}
}

if(antifake.includes(ale.id)) {
if (ale.action === 'add' && ale.participants[0].startsWith(55800)){
num = ale.participants[0]
conn.sendMessage(mdata.id, {text: ' â›¹ï¸â›¹ï¸Bye Bye Estrangeiro...ğŸ‘‹ğŸŒï¸'})
await delay(1000)
conn.groupParticipantsUpdate(mdata.id, [ale.participants[0]], 'remove')
}
}

// FIM ANTIFAKE ^

// BEM VINDO COMPLETO 


if(welkom.includes(ale.id)) {
if(antifake.includes(ale.id) && !ale.participants[0].startsWith(55)) return
try {
  
// PEGAR DESCRIÃ‡ÃƒO DO GRUPO. 

const groupDesc = await groupMetadata.desc  
  
try {
ppimg = await conn.profilePictureUrl(ale.participants[0])
} catch {
ppimg = 'https://telegra.ph/file/b5427ea4b8701bc47e751.jpg'
}

try {
ppgp = await conn.profilePictureUrl(mdata.id)
} catch {
ppgp = 'https://image.flaticon.com/icons/png/512/124/124034.png'
}

shortpc = await axios.get(`https://tinyurl.com/api-create.php?url=${ppimg}`)
shortgc = await axios.get(`https://tinyurl.com/api-create.php?url=${ppgp}`)

const groupIdWelcomed = []
const groupIdBye = []
for(let obj of welcome_group) groupIdWelcomed.push(obj.id)
for(let obj of bye_group) groupIdBye.push(obj.id)


const isByed = groupIdBye.indexOf(ale.id) >= 0 ? true : false

const isWelcomed = (groupIdWelcomed.indexOf(ale.id) >= 0) ? true : false

if(ale.action === 'add') {
if(isWelcomed) {
var ind = groupIdWelcomed.indexOf(ale.id)
teks = welcome_group[ind].msg
.replace('#hora#', time)
.replace('#nomedogp#', mdata.subject)
.replace('#numerodele#', '@'+ale.participants[0].split('@')[0])
.replace('#numerobot#', conn.user.id)
.replace('#prefixo#', prefix)
.replace('#descriÃ§Ã£o#', groupDesc)
} else {
teks = welcome(ale.participants[0].split('@')[0], mdata.subject)
}
let buff = await getBuffer(ppimg)
ran = getRandom('.jpg')
await fs.writeFileSync(ran, buff)

fs.unlinkSync(ran)
imgbuff = await getBuffer(`https://aleatoryapi.herokuapp.com/welcome?titulo=BEM%20VINDO(A)&nome=${ale.participants[0].split('@')[0]}&perfil=${shortpc.data}&fundo=${fundo1}&grupo=BEM VINDO AO GRUPO ${encodeUrl(mdata.subject)}`)
conn.sendMessage(mdata.id, {image: imgbuff, 
mentions: ale.participants, caption: teks})

} else if(ale.action === 'remove') {
mem = ale.participants[0]

try {
ppimg = await conn.profilePictureUrl(`${mem.split('@')[0]}@c.us`)
} catch {
ppimg = 'https://telegra.ph/file/b5427ea4b8701bc47e751.jpg'
}


if(isByed) {
var ind = groupIdBye.indexOf(ale.id)
teks = bye_group[ind].msg
.replace('#hora#', time)
.replace('#nomedogp#', mdata.subject)
.replace('#numerodele#', ale.participants[0].split('@')[0])
.replace('#numerobot#', conn.user.id)
.replace('#prefixo#', prefix)
.replace('#descriÃ§Ã£o#', groupDesc)
} else {
teks = bye(ale.participants[0].split('@')[0])
}

let buff = await getBuffer(ppimg)
ran = getRandom('.jpg')
fs.writeFileSync(ran, buff)

imgbuff = await getBuffer(`https://aleatoryapi.herokuapp.com/welcome?titulo=Adeus&nome=${ale.participants[0].split('@')[0]}&perfil=${shortpc.data}&fundo=${fundo1}&grupo=SAIU DE ${encodeUrl(mdata.subject)}`)
conn.sendMessage(mdata.id, {image: imgbuff, caption: teks, 
mentions: ale.participants})
 fs.unlinkSync(ran)

}
} catch (e) {
console.log(e);
}
}
})
// FIM ^


// BEM VINDO 2 ( SEM FOTO )

conn.ev.on('creds.update', saveState);
conn.ev.on('group-participants.update', async (ale) => {
 

if(welkom2.includes(ale.id)) {
if(antifake.includes(ale.id) && !ale.participants[0].startsWith(55)) return
try {

const groupMetadata = await conn.groupMetadata(ale.id) 
  
const mdata = await conn.groupMetadata(ale.id)  

// PEGAR DESCRIÃ‡ÃƒO DO GRUPO

const groupDesc = await groupMetadata.desc

const groupIdWelcomed2 = []
const groupIdBye2 = []
for(let obj of welcome_group2) groupIdWelcomed2.push(obj.id)
for(let obj of bye_group2) groupIdBye2.push(obj.id)


const isByed2 = groupIdBye2.indexOf(ale.id) >= 0 ? true : false

const isWelcomed2 = (groupIdWelcomed2.indexOf(ale.id) >= 0) ? true : false

if(ale.action === 'add') {
if(isWelcomed2) {
var ind = groupIdWelcomed2.indexOf(ale.id)
teks = welcome_group2[ind].msg
.replace('#hora#', time)
.replace('#nomedogp#', mdata.subject)
.replace('#numerodele#', '@'+ale.participants[0].split('@')[0])
.replace('#numerobot#', conn.user.id)
.replace('#prefixo#', prefix)
.replace('#descriÃ§Ã£o#', groupDesc)
} else {
teks = welcome(ale.participants[0].split('@')[0], mdata.subject)
}

conn.sendMessage(mdata.id, {text: teks}, {mentions: ale.participants})

} else if(ale.action === 'remove') {
mem = ale.participants[0]

if(isByed2) {
var ind = groupIdBye2.indexOf(ale.id)
teks = bye_group2[ind].msg
.replace('#hora#', time)
.replace('#nomedogp#', mdata.subject)
.replace('#numerodele#', ale.participants[0].split('@')[0])
.replace('#numerobot#', conn.user.id)
.replace('#prefixo#', prefix)
.replace('#descriÃ§Ã£o#', groupDesc)
} else {
teks = bye(ale.participants[0].split('@')[0])
}

conn.sendMessage(mdata.id, {text: teks}, {mentions: ale.participants})
 fs.unlinkSync(ran)
}
} catch (e) {
console.log(e);
}
}
})
// FIM BEM VINDO (2)


conn.ev.on('connection.update', (update) => {
const { connection, lastDisconnect, qr} = update

if(qr) {
console.log(color("VOCÃŠ PRECISARÃ DE UM SEGUNDO CELULAR, PARA TIRAR FOTO DO QRCODE, PRA DEPOIS ESCANEAR A FOTO QUE TIROU"))
}

{
if(!fs.existsSync("auth_info_multi.json")) return
}

if(connection === 'close') {
var shouldReconnect = ((lastDisconnect.error)?.output?.statusCode !== DisconnectReason.loggedOut)

console.log('ConexÃ£o fechada devido a ', lastDisconnect.error, ', Reconectar ', shouldReconnect)

console.log(color("Boa sorte, caso de bugs, apenas desligue e ligue novamente, pressionando volume de menos do celular e apertando letra C"))

if(String(lastDisconnect.error).includes("Connection Failure")) {
exec("rm baileys_store_multi.json")  
exec("rm auth_info_multi.json")
console.log(color("QRCODE ESTÃ MORTO, NÃƒO ESCANEOU CORRETAMENTE, IREI APAGAR ELE E GERAR UM NOVO QRCODE, BOA SORTE..", "red"))
process.exit()
}

if(String(lastDisconnect.error).includes("Stream Errored")) {
process.exit()
}

if(String(lastDisconnect.error)) {
startAle()
}

}

if(connection === 'connecting') {
 start('2', 'CONECTANDO ALEATORY MD 2.0..')    
}

if(connection === 'open') {
success('2', 'ALEATORY MD 2.0 CONECTADO COM SUCESSO..')
}

if(update.isNewLogin) {
 startAle()
}

})

conn.ev.on('chats.set', item => console.log(`recv ${item.chats.length} Chats (is latest: ${item.isLatest})`))

conn.ev.on('messages.set', item => console.log(`recv ${item.messages.length} Mensagens (is latest: ${item.isLatest})`))

conn.ev.on('contacts.set', item => console.log(`recv ${item.contacts.length} Contatos`))


conn.ev.on('messages.upsert', async ({ messages }) => {
try {
const info = messages ? messages[0]: messages[1]
if (!info.message) return 
saveState()
if (info.message.protocolMessage) return 
if(info.message > 1000) return
await conn.sendReadReceipt(info.key.remoteJid, info.key.participant, [info.key.id])
if (info.key && info.key.remoteJid == 'status@broadcast') return

const altpdf = Object.keys(info.message)
const type = altpdf[0] == 'senderKeyDistributionMessage' ? altpdf[1] == 'messageContextInfo' ? altpdf[2] : altpdf[1] : altpdf[0]

global.prefix

global.blocked

const content = JSON.stringify(info.message)
const speed = require('performance-now');
const from = info.key.remoteJid
const isGroup = from.endsWith('@g.us')

//==============(BODY)================\\
var body = (type === 'conversation') ? info.message.conversation : (type === 'imageMessage') ? info.message.imageMessage.caption : (type === 'videoMessage') ? info.message.videoMessage.caption : (type === 'extendedTextMessage') ? info.message.extendedTextMessage.text : (type === 'buttonsResponseMessage') ? info.message.buttonsResponseMessage.selectedButtonId : (type === 'listResponseMessage') ? info.message.listResponseMessage.singleSelectReply.selectedRowId : (type === 'templateButtonReplyMessage') ? info.message.templateButtonReplyMessage.selectedId : ''

const args = body.trim().split(/ +/).slice(1)
const isCmd = body.startsWith(prefix)
const command = isCmd ? body.slice(1).trim().split(/ +/).shift().toLocaleLowerCase() : null

//================(BADY)================\\

bady = (type === 'conversation') ? info.message.conversation : (type == 'imageMessage') ? info.message.imageMessage.caption : (type == 'videoMessage') ? info.message.videoMessage.caption : (type == 'extendedTextMessage') ? info.message.extendedTextMessage.text : (info.message.listResponseMessage && info.message.listResponseMessage.singleSelectReply.selectedRowId) ? info.message.listResponseMessage.singleSelectReply.selectedRowId: ''

//=======================================\\


//===============(BUDY)==================\\

budy = (type === 'conversation') ? info.message.conversation : (type === 'extendedTextMessage') ? info.message.extendedTextMessage.text : ''

//======================================\\

var pes = (type === 'conversation' && info.message.conversation) ? info.message.conversation : (type == 'imageMessage') && info.message.imageMessage.caption ? info.message.imageMessage.caption : (type == 'videoMessage') && info.message.videoMessage.caption ? info.message.videoMessage.caption : (type == 'extendedTextMessage') && info.message.extendedTextMessage.text ? info.message.extendedTextMessage.text : ''

//===========(ID DAS FIGUS)===========\\

const figura = Object.keys(info.message)[0] == "stickerMessage" ? info.message.stickerMessage.fileSha256.toString('base64') : ""

//=====================================\\

const groupMetadata = isGroup ? await conn.groupMetadata(from) : ''
const groupName = isGroup ? groupMetadata.subject : ''
const sender = isGroup ? info.key.participant : info.key.remoteJid
const pushname = info.pushName ? info.pushName : ''

const messagesC = pes.slice(0).trim().split(/ +/).shift().toLowerCase()

const arg = body.substring(body.indexOf(' ') + 1)

const botNumber = conn.user.id.split(':')[0]+'@s.whatsapp.net'
const argss = body.split(/ +/g)
const testat = body
const ants = body
const tescuk = ["0@s.whatsapp.net"]
const q = args.join(' ')

const groupDesc = isGroup ? groupMetadata.desc : ''

const groupMembers = isGroup ? groupMetadata.participants : ''

const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''

//=======================================\\

const nmrdn = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`

const numerodono = [`${nmrdn}`, `${nescessario.dono1}@s.whatsapp.net`, `${nescessario.dono2}@s.whatsapp.net`, `${nescessario.dono3}@s.whatsapp.net`, `${nescessario.dono4}@s.whatsapp.net`, `${nescessario.dono5}@s.whatsapp.net`, `${nescessario.dono6}@s.whatsapp.net`]

//============(SORTEIO-CONST)============\\

const { infosorteio } = require('./armor/js/infosorteio.js')

//===========(enviar.espere)=============\\

const { mensagens } = require('./armor/js/aleatoria.js');

const { sortear } = require('./armor/js/aleatoria.js');

var enviarmen = mensagens[Math.floor(Math.random() * mensagens.length)] 
//========================================\\

//=======(ADMS/DONO/ETC..CONST)========\\

const quoted = info.quoted ? info.quoted : info

const isBot = info.key.fromMe ? true : false

const SoDono = numerodono.includes(sender) || isBot

const DonoOficial = setting.numerodono.includes(sender) 

const isPremium = premium.includes(sender)

const isBotGroupAdmins = groupAdmins.includes(botNumber) || false

const isGroupAdmins = groupAdmins.includes(sender) || false 

//============(FUNÃ‡Ã•ES)============\\

const isWelkom2 = isGroup ? welkom2.includes(from) : true

const isVote = isGroup ? voting.includes(from) : false

const isModobn =  isGroup ? modobn.includes(from) : true

const isNsfw =  isGroup ? nsfw.includes(from) : true

const isSimi = isGroup ? samih.includes(from) : false

const isSimi2 = isGroup ? samih2.includes(from) : false

const isBanned = ban.includes(sender)

//===========(ANTIS-PROTEÃ‡Ã•ES)===========\\

const isAntifake = isGroup ? antifake.includes(from) : false

const isAntiCtt = isGroup ? antictt.includes(from) : false

const isAnticatalogo = isGroup ? anticatalogo.includes(from) : false

const isAntiLink = isGroup ? antilink.includes(from) : false

const isAntiFlood = isGroup ? antiflood.includes(from) : false	

const isnit = nit.includes(sender) 

const isAntiLinkHard = isGroup ? antilinkhard.includes(from) : false

const isJoguin = isGroup ? joguinhodavelhajs.includes(sender) : false

const isAntilinkgp = isGroup ? antilinkgp.includes(from) : false

const isAntiAudio = isGroup ? antiaudio.includes(from) : false	
	
const isAntiImg = isGroup ? antiimg.includes(from) : false

const isAntiSticker = isGroup ? antisticker.includes(from) : false

const isAntiNotas = isGroup ? antinotas.includes(from) : false

const Antidoc = isGroup ? antidoc.includes(from) : false

const Antiloc = isGroup ? antiloc.includes(from) : false

const isAntiVid = isGroup ? antivid.includes(from) : false	

const ischyt = chyt.includes(sender)

const isAntiPv = (antipv.indexOf('Ativado') >= 0) ? true : false	

const isAnticall = (anticall.indexOf('Ativado') >= 0) ? true : false

const isPalavrao = isGroup ? palavrao.includes(from) : false	

const isViewOnce = (type == 'viewOnceMessage')

//=======================================\\

enviar = {
espere: `${enviarmen}`,
successo: 'ï¸â¬ âœ” â­ Sucesso ğŸ–¤',
levelon: 'â¬ âœ” â­ *leveling* *ativado*',
leveloff: 'â¬ X â­  *leveling* *desativado*',
levelnoton: 'â¬ X â­ *leveling nÃ£o ativado*',
levelnol: '*error* 0 Â°-Â°',
error: {
stick: '*falhou, tente novamente ^_^*',
Iv: 'Link invalido â˜¹ï¸'
},
msg: {
grupo: '[â—] Este comando sÃ³ pode ser usado em grupos! âŒ',
premium: '[â—] ESTE PEDIDO Ã‰ SO PARA *USUÃRIOS PREMIUMS*',
mod: `[â—] ESTE PEDIDO Ã‰ ESPECÃFICO PARA USUARIO MOD ${setting.NickDono}*`,
banido: 'âŒ VocÃª foi banido de utilizar os comandos, entre em contato com o proprietÃ¡rio pra saber o porque âŒ' ,
donosmt: '[â—] Este Ã© um recurso especial para o proprietÃ¡rio âŒ',
donosmt2: '[â—] Este Ã© um recurso especial para o proprietÃ¡rio âŒ',
adm: '[â—] Este comando sÃ³ pode ser usado por administradores de grupo! âŒ',
Badmin: ' [â—] Este comando sÃ³ pode ser usado quando o bot se torna administrador! âŒ',
}
}

//=========(CONSTS-FUNÃ‡Ã•ES)============\\

const isWelkom = isGroup ? welkom.includes(from) : false

const issupre = supre.includes(sender)

const isLevelingOn = isGroup ? _leveling.includes(from) : false

const isBanchat = isGroup ? bancht.includes(from) : false	

//=====================================\\



//==========(VERIFICADO)===============\\

const selo = { key: {fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": `${NomeDoBot}`, 'jpegThumbnail': fs.readFileSync('./logos/logo2.jpg')}}}

//=====================================\\

const reply = (texto) => {
conn.sendMessage(from, { text: texto }, {quoted: info})
}

const getGroup = async function(totalchat){
let grup = []
let a = []
let b = []
for (c of totalchat){
a.push(c.id)
}
for (d of a){
if (d && d.includes('g.us')){
b.push(d)
}
}
for (e of b){
let ingfo = await conn.groupMetadata(e)
grup.push(ingfo)
}
return grup
}  


const isUrl = (url) => {
if(linkfy.find(url)[0]) return true
return false
}	

const time2 = moment().tz('America/Sao_Paulo').format('HH:mm:ss')
if(time2 > "00:00:00"){
var tempo = 'Boa madrugada'
                                        } 
if(time2 > "05:30:00"){
var tempo = 'Bom dia'
                                        }
if(time2 > "12:00:00"){
var tempo = 'Boa tarde'
                                        }
if(time2 > "19:00:00"){
var tempo = 'Boa noite'
                                        }


const getFileBuffer = async (mediakey, MediaType) => {
  
const stream = await downloadContentFromMessage(mediakey, MediaType)

let buffer = Buffer.from([])
for await(const chunk of stream) {
buffer = Buffer.concat([buffer, chunk])
}
return buffer
}

const sendSticker = (from, filename, info) => {
conn.sendMessage(from, {sticker: filename}, {quoted: info})
}

const sendImage = (ytb) => {
conn.sendMessage(from, {image: ytb}, {quoted:info})
}


const sendMess = (hehe, ytb) => {
conn.sendMessage(hehe, {text: ytb})
}


const mentions = (teks, memberr, id) => {
(id == null || id == undefined || id == false) ? conn.sendMessage(from, {text: teks.trim(), mentions: memberr}) : conn.sendMessage(from, {text: teks.trim(), mentions: memberr})
}
	
const costum = (pesan, tipe, target, target2) => {
conn.sendMessage(from, pesan, tipe, {quoted: {key: {fromMe: false, participant: `${target}`, ...(from ? {remoteJid: from}: {})}, message: {conversation: `${target2}` }}})
}


const groupIdWelcomed = []	
for(let obj of welcome_group) groupIdWelcomed.push(obj.id)

const groupIdBye = []
for(let obj of bye_group) groupIdBye.push(obj.id)

const isWelcomed = (groupIdWelcomed.indexOf(from) >= 0) ? true : false

const isByed = (groupIdBye.indexOf(from) >= 0) ? true : false

const groupIdWelcomed2 = []	

for(let obj of welcome_group2) groupIdWelcomed2.push(obj.id)

const groupIdBye2 = []

for(let obj of bye_group2) groupIdBye2.push(obj.id)


const isWelcomed2 = (groupIdWelcomed2.indexOf(from) >= 0) ? true : false

const isByed2 = (groupIdBye2.indexOf(from) >= 0) ? true : false	
	
	
//=====(FUNÃ‡ÃƒO-CHECAR-LIMIT)====\\
const checkLimit = (sender) => {
let found = false
for (let lmt of _limit) {
if (lmt.id === sender) {
let limitCounts = limitawal - lmt.limit
if (limitCounts <= 0) return conn.sendMessage(from,{text: `[ğŸ‘¾] *LIMIT ESGOTADO*\n\n_Nota : para obter mais limit compre usando *${prefix}buylimit* ou suba de nÃ­vel...`},{sendEphemeral: true, contextInfo: { forwardingScore: 50, isForwarded: true}, quoted: info})
conn.sendMessage(from, {text: jrpl.limitcount(limitCounts)}, { quoted : info})
found = true
}
}
if (found === false) {
let obj = { id: sender, limit: 0 }
_limit.push(obj)
fs.writeFileSync('./datab/grupos/limit.json', JSON.stringify(_limit))
conn.sendMessage(from, {text: jrpl.limitcount(limitCounts)}, { quoted : info})
}
} 
							
	//funtion limitado
const isLimit = (sender) =>{ 
if (issupre) {return false;}
let position = false
for (let i of _limit) {
if (i.id === sender) {
let limits = i.limit
if (limits >= limitawal ) {
position = true
conn.sendMessage(from, {text: jrpl.limitend(pushname)}, {sendEphemeral: true, contextInfo: { forwardingScore: 50, isForwarded: true}, quoted: info})
return true
} else {
_limit
position = true
return false
}
}
}
if (position === false) {
const obj = { id: sender, limit: 0 }
_limit.push(obj)
fs.writeFileSync('./datab/grupos/limit.json',JSON.stringify(_limit))
return false
}
}
	
const sendFileFromUrl = async (from, url, caption, info, men) => {
let mime = ''; 
let res = await axios.head(url)
mime = res.headers['content-type'] 
if (mime.split("/")[1] === "gif") { 
return conn.sendMessage(from, {video: await getBuffer(url),
caption: caption, gifPlayback: true, 
mentions: men ? men : []}, {quoted: info}) 
}
 
let type = mime.split("/")[0]+"Message" 
if(mime === "application/pdf"){ 
return conn.sendMessage(from, {document: await getBuffer(url), mimetype: 'application/pdf', 
caption: caption, mentions: men ? men : []}, {quoted: info}) 
} 

if(mime.split("/")[0] === "image"){ 
return conn.sendMessage(from, {image: await getBuffer(url), caption: caption, mentions: men ? men : []}, {quoted: info}) 
}
if(mime.split("/")[0] === "video"){ 
return conn.sendMessage(from, {video: await getBuffer(url), caption: caption, mentions: men ? men : []}, {quoted: info}) 
} 
if(mime.split("/")[0] === "audio"){ 
return conn.sendMessage(from, {audio: await getBuffer(url), caption: caption, mentions: men ? men : [], mimetype: 'audio'}, {quoted: info}) 
}
}
	
const sendMediaURL = async(to, url, text ="", mids=[]) =>{
if(mids.length > 0){
text = normalizeMention(to, text, mids)
}
const fn = Date.now() / 10000;
const filename = fn.toString()
let mime = ""
var download = function (uri, filename, callback) {
request.head(uri, function (err, res, body) {
mime = res.headers['content-type']
request(uri).pipe(fs.createWriteStream(filename)).on('close', callback);
});
};
download(url, filename, async function () {
console.log('done');
let media = fs.readFileSync(filename)
let type = mime.split("/")[0]+"Message"
if(mime === "image/gif"){
type = video
mime = Mimetype.gif
}
if(mime.split("/")[0] === "audio"){
mime = Mimetype.mp4Audio
}
conn.sendMessage(to, {type: media, mimetype: mime, caption: text, contextInfo: {"mentionedJid": mids}}, { quoted: info})
fs.unlinkSync(filename)
});
}   

/********** ANTI NOME MODIFICADO **********/
function isDoubleByte(str) {
for (let i = 0, n = str.length; i < n; i++) {
if (str.charCodeAt(i) > 255) {
return true;
}
}
return false;
}

// ENVIAR BOTÃƒO COM TEXTO
const sendBtext = async (id, text1, desc1, but = [], vr) => {
buttonMessage = {
text: text1,
footer: desc1,
buttons: but,
headerType: 1
}
conn.sendMessage(id, buttonMessage, {quoted: vr})
}

// ENVIAR BOTÃƒO COM IMAGEM
const sendBimg = async (id, img1, text1, desc1, but = [], vr) => {
buttonMessage = {
image: {url: img1},
caption: text1,
footerText: desc1,
buttons: but,
headerType: 4
}
conn.sendMessage(id, buttonMessage, {quoted: vr})
}

// PRA ENVIAR BOTÃƒO DE TEMPLATE
const sendBimgT = async (id, img1, text1, desc1, but = [], vr) => {
templateMessage = {
image: {url: img1},
caption: text1,
footer: desc1,
templateButtons: but,
}
conn.sendMessage(id, templateMessage, {quoted: vr})
}

const enviarfigu = async (figu, tag) => {
bla = fs.readFileSync(figu)
conn.sendMessage(from, {sticker: bla}, {quoted: info})
}

var nmrdnofc1 = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "")

if(isGroup && fs.existsSync(`./func/afk/afk-@${nmrdnofc1}.json`)) {
if(budy.includes(`@${nmrdnofc1}`)) {
const tabelin = JSON.parse(fs.readFileSync(`./func/afk/afk-@${nmrdnofc1}.json`));  

txt = `- OlÃ¡, o ${NickDono} EstÃ¡ ausente.\n\n - Desde: ${tabelin.Ausente_Desde}\n\n- ğŸ˜‡ Mensagem de ausÃªncia : ${tabelin.Motivo_Da_AusÃªncia}`

conn.sendMessage(from, {text: txt}, {quoted: info})
}
}
 
if(isGroup) {
if(info.message == "inviteLinkGroupType") return reply("oi") 
}
 
 
//========================================\\
//BAN CHATS/GRUPOS
if (isBanchat && !isGroupAdmins && !SoDono){
if (!isGroupAdmins && !SoDono) return
if (budy.toLowerCase().startsWith('unbangp')){
if (isCmd && !isBanchat && !isGroupAdmins) return reply(`Este grupo esta banido, ou seja nÃ£o estou ouvindo ninguÃ©m`)
let lfd = bancht.indexOf(from)
bancht.splice(lfd, 1)
fs.writeFileSync('./datab/grupos/banchat.json', JSON.stringify(bancht))
reply(`Grupo desbanido...`)
}
}

//=======FUNCIONALIDADE PATENTE=========\\
const nivelAtual = getLevelingLevel(sender)
var patt = 'Bronze IğŸ¥‰'
if (nivelAtual === 1) {patt = 'Bronze  IğŸ¥‰' } else if (nivelAtual === 2) {patt = 'Bronze IIğŸ¥‰'} else if (nivelAtual === 3) {patt = 'Bronze  IIIğŸ¥‰'} else if (nivelAtual === 4) {patt = 'Bronze  IVğŸ¥‰'} else if (nivelAtual === 5) {patt = 'Bronze  VğŸ¥‰'} else if (nivelAtual === 6) {patt = 'Prata IğŸ¥ˆ'} else if (nivelAtual === 7) {patt = 'Prata IIğŸ¥ˆ'} else if (nivelAtual === 8) {patt = 'Prata IIIğŸ¥ˆ'} else if (nivelAtual === 9) {patt = 'Prata IVğŸ¥ˆ'} else if (nivelAtual === 10) {patt = 'Prata VğŸ¥ˆ'} else if (nivelAtual === 11) {patt = 'Ouro IğŸ¥‡'} else if (nivelAtual === 12) {patt = 'Ouro IIğŸ¥‡'} else if (nivelAtual === 13) {patt = 'Ouro IIIğŸ¥‡'} else if (nivelAtual === 14) {patt = 'Ouro IVğŸ¥‡'} else if (nivelAtual === 15) {patt = 'Ouro VğŸ¥‡'} else if (nivelAtual === 16) {patt = 'CampeÃ£o IğŸ†'} else if (nivelAtual === 17) {patt = 'CampeÃ£o IIğŸ†'} else if (nivelAtual === 18) {patt = 'CampeÃ£o IIIğŸ†'} else if (nivelAtual === 19) {patt = 'CampeÃ£o IVğŸ†'} else if (nivelAtual === 20) {patt = 'CampeÃ£o VğŸ†'} else if (nivelAtual === 21) {patt = 'Diamante I ğŸ’'} else if (nivelAtual === 22) {patt = 'Diamante II ğŸ’'} else if (nivelAtual === 23) {patt = 'Diamante III ğŸ’'} else if (nivelAtual === 24) {patt = 'Diamante IV ğŸ’'} else if (nivelAtual === 25) {patt = 'Diamante V ğŸ’'} else if (nivelAtual === 26) {patt = 'Mestre I ğŸ‚'} else if (nivelAtual === 27) {patt = 'Mestre II ğŸ‚'} else if (nivelAtual === 28) {patt = 'Mestre III ğŸ‚'} else if (nivelAtual === 29) {patt = 'Mestre IV ğŸ‚'} else if (nivelAtual === 30) {patt = 'Mestre V ğŸ‚'} else if (nivelAtual === 31) {patt = 'MÃ­tico I ğŸ”®'} else if (nivelAtual === 32) {patt = 'MÃ­tico II ğŸ”®'} else if (nivelAtual === 33) {patt = 'MÃ­tico III ğŸ”®'} else if (nivelAtual === 34) {patt = 'MÃ­tico IV ğŸ”®'} else if (nivelAtual === 35) {patt = 'MÃ­tico V ğŸ”®'} else if (nivelAtual === 36) {patt = 'God IğŸ•´'} else if (nivelAtual === 37) {patt = 'God IIğŸ•´'} else if (nivelAtual === 38) {patt = 'God IIIğŸ•´'} else if (nivelAtual === 39) {patt = 'God IVğŸ•´'} else if (nivelAtual === 40) {patt = 'God VğŸ•´'} else if (nivelAtual > 41) {patt = 'ğŸ›Grande MestreğŸ›'}
//========================================\\



//==========(FUNÃ‡ÃƒO DE LEVEL)=============\\
if (isGroup && isLevelingOn) {
const currentLevel = getLevelingLevel(sender)
const checkId = getLevelingId(sender)
try {
if (currentLevel === undefined && checkId === undefined) addLevelingId(sender)
const amountXp = Math.floor(Math.random() * 10) + 500
const requiredXp = 5000 * (Math.pow(2, currentLevel) - 1)
const getLevel = getLevelingLevel(sender)
addLevelingXp(sender, amountXp)
if (requiredXp <= getLevelingXp(sender)) {
addLevelingLevel(sender, 1)
await reply(`            â—ª LEVEL UP â—ª\n\nâ”œâ”€ â NÃšMERO: ${sender.split("@")[0]}.                                                                                       â”œâ”€ â *PATENTE*: ${patt}\nâ”œâ”€ â XP: ${getLevelingXp(sender)}\nâ””â”€ â LEVEL: ${getLevel} -> ${getLevelingLevel(sender)}`)
}
} catch (err) {
console.error(err)
}
}
//=======================================\\



const sendStickerFromUrl = async(to, url) => {
var names = Date.now() / 10000;
var download = function (uri, filename, callback) {
request.head(uri, function (err, res, body) {
request(uri).pipe(fs.createWriteStream(filename)).on('close', callback);
});
};
download(url, './sticker' + names + '.png', async function () {
console.log('enviando sticker');
let filess = './sticker' + names + '.png'
let asw = './sticker' + names + '.webp'
exec(`ffmpeg -i ${filess} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${asw}`, (err) => {
let media = fs.readFileSync(asw)
conn.sendMessage(to, {sticker: media}, {sendEphemeral: true, contextInfo: { forwardingScore: 50, isForwarded: true}, quoted: info})
fs.unlinkSync(filess)
fs.unlinkSync(asw)
});
});
}


//===================================\\

		//JOGO DO ANAGRAM
if(isGroup && fs.existsSync(`./armor/anagrama-${from}.json`)){
let dataAnagrama = JSON.parse(fs.readFileSync(`./armor/anagrama-${from}.json`))
if(budy.slice(0,4).toUpperCase() == dataAnagrama.original.slice(0,4).toUpperCase() && budy.toUpperCase() != dataAnagrama.original) return reply('estÃ¡ perto')
xp = Math.floor(Math.random() * 14) + 3000
if(budy.toUpperCase() == dataAnagrama.original) { conn.sendMessage(from, {text: `parabÃ©ns ${pushname} ğŸ¥³ vocÃª ganhou o jogo\nPalavra : ${dataAnagrama.original}\nIniciando o proximo jogo em 5 segundos...`}, {"mentionedJid": [sender]}), fs.unlinkSync(`./armor/anagrama-${from}.json`)		
addLevelingXp(sender, xp)
recompensa = `ğŸ‰ğŸ‰RECOMPENSAğŸ‰ğŸ‰\nVocÃª ganhou ${xp} em *xp*`
reply(recompensa)
		setTimeout(async() => {
fs.writeFileSync(`./armor/anagrama-${from}.json`, `${JSON.stringify(palavrasANA[Math.floor(Math.random() * palavrasANA.length)])}`)
let dataAnagrama2 = JSON.parse(fs.readFileSync(`./armor/anagrama-${from}.json`))
conn.sendMessage(from, {text:`
â•­â”€â”€â”€â”€â”€â‰½ã€Œ ğŸ‘¾ ANAGRAMA ğŸ‘¾ ã€
â”‚â½ DESCUBRA A PALAVRA
â”‚â½ ANAGRAMA: ${dataAnagrama2.embaralhada}
â”‚â½ DICA: ${dataAnagrama2.dica}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`}) 
}, 5000)
}}

//========================================\\


		//JOGO QUIZ
if(isGroup && fs.existsSync(`./armor/quizanim-${from}.json`)){
let dataAnagramaa = JSON.parse(fs.readFileSync(`./armor/quizanim-${from}.json`))
if(budy.slice(0,4).toUpperCase() == dataAnagramaa.original.slice(0,4).toUpperCase() && budy.toUpperCase() != dataAnagramaa.original) return reply('estÃ¡ perto')
if(budy.toUpperCase() == dataAnagramaa.original) { 
conn.sendMessage(from,{text: `ParabÃ©ns ${pushname} vocÃª acertou\n${dataAnagramaa.original}\nProximo em 5 segundos...`}, {"mentionedJid": [sender]}), fs.unlinkSync(`./armor/quizanim-${from}.json`)		
setTimeout(async() => {
fs.writeFileSync(`./armor/quizanim-${from}.json`, `${JSON.stringify(quizanimais[Math.floor(Math.random() * quizanimais.length)])}`)
let dataAnagrama2 = JSON.parse(fs.readFileSync(`./armor/quizanim-${from}.json`))
imagemtexto =`                             ã€Œâ“Quizâ“ã€`
wew = await getBuffer(`${dataAnagrama2.foto}`)   
if(verificado === true) {
await conn.sendMessage(from, {image: wew, caption: imagemtexto, thumbnail: wew}, {quoted: selo})
} else {
await conn.sendMessage(from, {image: wew, caption: imagemtexto, thumbnail: wew}, {quoted: info})  
}
}, 5000)
}}

const sleep = async (ms) => {return new Promise(resolve => setTimeout(resolve, ms))}

//=========(isQuoted/consts)=============\\
const isImage = type == 'imageMessage'
const isVideo = type == 'videoMessage'
const isAudio = type == 'audioMessage'
const isSticker = type == 'stickerMessage'
const isContact = type == 'contactMessage'
const isLocation = type == 'locationMessage'
const isProduct = type == 'productMessage'
const isMedia = (type === 'imageMessage' || type === 'videoMessage' || type === 'audioMessage')
typeMessage = body.substr(0, 50).replace(/\n/g, '')
if (isImage) typeMessage = "Image"
else if (isVideo) typeMessage = "Video"
else if (isAudio) typeMessage = "Audio"
else if (isSticker) typeMessage = "Sticker"
else if (isContact) typeMessage = "Contact"
else if (isLocation) typeMessage = "Location"
else if (isProduct) typeMessage = "Product"

const isQuotedMsg = type === 'extendedTextMessage' && content.includes('textMessage')

const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')

const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')

const isQuotedDocument = type === 'extendedTextMessage' && content.includes('documentMessage')

const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')

const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')

const isQuotedContact = type === 'extendedTextMessage' && content.includes('contactMessage')

const isQuotedLocation = type === 'extendedTextMessage' && content.includes('locationMessage')

const isQuotedProduct = type === 'extendedTextMessage' && content.includes('productMessage')
             

///////////ANTI-SPAM BY ITALU/////////
if (isCmd && isFiltered(sender) && !isGroup) {
console.log(color('~> [SPAM]', 'red'), color(moment.tz('America/Sao_Paulo').format('HH:mm:ss'), 'yellow'), color(`${command}`), 'DE:', color(pushname))
const ff = `*ã€Œ â— ã€Flood detectado, espere 5 segundos*`
return reply(ff)
}
if (isCmd && isFiltered(sender) && isGroup) {
console.log(color('~> [SPAM]', 'red'), color(moment.tz('America/Sao_Paulo').format('HH:mm:ss'), 'yellow'), color(`${command}`), 'DE:', color(pushname))
const ff1 = `*ã€Œ â— ã€Flood detectado, espere 5 segundos*`
return reply(ff1)
}

//////BLOCK CMD///////
//(CREDITOS AO KAUAN GAY)\\
if(isGroup){
const checar = getComandos(from)
if(checar === undefined) addComandosId(from)
}
if(isGroup && isCmd && !SoDono && !isnit && getComandoBlock(from).includes(command))return reply('comando blockeado')

////FIMMMMMMMMM/////,

if (!isGroup && isCmd) console.log('\033[0;35m~\x1b[1;37m>', '[\x1b[1;32mCOMANDO\x1b[1;37m]', time, color(command), 'do ', color(sender.split('@')[0]))

if (!isGroup && !isCmd && !info.key.fromMe) console.log('\033[0;35m~\x1b[1;37m>', '[\033[0;35mMENSAGEM\x1b[1;37m]', 'do ', color(sender.split('@')[0]))

if (isCmd && isGroup) console.log('\033[0;35m~\x1b[1;37m>', '[\x1b[1;32mCOMANDO\x1b[1;37m]', time, color(command), 'do ', color(sender.split('@')[0]), 'no gp: ', color(groupName))

if (!isCmd && isGroup && !info.key.fromMe) console.log('\033[0;35m~\x1b[1;37m>', '[\033[0;35mMENSAGEM\x1b[1;37m]',  'do ', color(sender.split('@')[0]), 'no gp: ', color(groupName))
//======(JOGO-DA-VELHA)=======(FunÃ§Ã£o)===\\

//////////_FUNÃ‡Ã•ES DO JOGO DA VELHA_//////
async function joguinhodavelha() {
if(joguinhodavelhajs2.includes(from) || joguinhodavelhajs.includes(sender)) {
const cmde = budy.toLowerCase().split(" ")[0] || "";
let arrNum = ["1", "2", "3", "4", "5", "6", "7", "8", "9"];
if (fs.existsSync(`./armor/tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
if (budy == "Cex") return reply("why");
if (
budy.toLowerCase() == "s" ||
budy.toLowerCase() == "sim" ||
budy.toLowerCase() == "ok"
) {
if (boardnow.O == sender.replace("@s.whatsapp.net", "")) {
if (boardnow.status)
return reply(`O jogo jÃ¡ comeÃ§ou antes!`);
const matrix = boardnow._matrix;
boardnow.status = true;
fs.writeFileSync(`./armor/tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
const chatAccept = `*ğŸ®á€Ì¸áªÌ¸á·Ì¸á¬Ì¸ á Ì¸áªÌ¸ á™Ì¸á¬Ì¸áÌ¸á»Ì¸áªÌ¸ğŸ•¹ï¸*
                    
âŒ : @${boardnow.X}
â­• : @${boardnow.O}
               
Sua vez... : @${boardnow.turn == "X" ? boardnow.X : boardnow.O}

${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}
${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}
${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}
`;
conn.sendMessage(from, {text: chatAccept}, {quoted: info,
contextInfo: {
mentionedJid: [
boardnow.X + "@s.whatsapp.net",
boardnow.O + "@s.whatsapp.net", 
],
},
});
}
} else if (
budy.toLowerCase() == "n" ||
budy.toLowerCase() == "nÃ£o" ||
budy.toLowerCase() == "no"
) {
if (boardnow.O == sender.replace("@s.whatsapp.net", "")) {
if (boardnow.status)
return reply(`O jogo jÃ¡ comeÃ§ou!`);
fs.unlinkSync(`./armor/tictactoe/db/${from}.json`);
 conn.sendMessage(from, {text:
 `@${boardnow.X} *_Infelizmente seu oponente nÃ£o aceitou o desafio âŒğŸ˜•_*`}, {quoted: info,
 contextInfo: {
 mentionedJid: [boardnow.X + "@s.whatsapp.net"],
},
}
);
joguinhodavelhajs.splice([])
fs.writeFileSync('./datab/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./datab/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
}
}
}

if (arrNum.includes(cmde)) {
const boardnow = setGame(`${from}`);
if (!boardnow.status) return reply(`Parece que seu oponente nÃ£o aceitou o desafio ainda...`)
if (
(boardnow.turn == "X" ? boardnow.X : boardnow.O) !=
     
sender.replace("@s.whatsapp.net", "")
)
return;
const moving = validmove(Number(budy), `${from}`);
const matrix = moving._matrix;
if (moving.isWin) {
if (moving.winner == "SERI") {
const chatEqual = `*ğŸ®á€Ì¸áªÌ¸á·Ì¸á¬Ì¸ á Ì¸áªÌ¸ á™Ì¸á¬Ì¸áÌ¸á»Ì¸áªÌ¸ğŸ•¹ï¸*
          
Jogo termina empatado ğŸ˜
`;
reply(chatEqual);
fs.unlinkSync(`./armor/tictactoe/db/${from}.json`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./datab/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs)) 
joguinhodavelhajs2.splice([])
fs.writeFileSync('./datab/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
return;
}
const abt = Math.ceil(Math.random() + 4000)
const winnerJID = moving.winner == "O" ? moving.O : moving.X;
const looseJID = moving.winner == "O" ? moving.X : moving.O;
const limWin = Math.floor(Math.random() * 1) + 10;
const limLoose = Math.floor(Math.random() * 1) + 5;
const chatWon = `*ğŸ®á€Ì¸áªÌ¸á·Ì¸á¬Ì¸ á Ì¸áªÌ¸ á™Ì¸á¬Ì¸áÌ¸á»Ì¸áªÌ¸ğŸ•¹ï¸*
          
Vencido por @${winnerJID} ğŸ˜ğŸ‘‘
`;
addLevelingXp(winnerJID + "@s.whatsapp.net", abt)

conn.sendMessage(from, {text: chatWon}, {quoted: info,
contextInfo: {
mentionedJid: [
moving.winner == "O" ?
moving.O + "@s.whatsapp.net" :
moving.X + "@s.whatsapp.net",
],
},
});
setTimeout( () => {
if (fs.existsSync("./armor/tictactoe/db/" + from + ".json")) {
 fs.unlinkSync("./armor/tictactoe/db/" + from + ".json");
 reply(`*ğŸ•¹ï¸JOGO DA VELHA RESETADO...ğŸ•¹ï¸*`);
 } else {
console.log(color(time, "red"), color("[ ESPIRADO ]", "magenta"), color('Jogo da velha espirado', "red"));
 }
joguinhodavelhajs.splice([])
fs.writeFileSync('./datab/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./datab/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
}, 300000) //5 minutos
reply(`_*ğŸ¥³ParabÃ©ns @${winnerJID} VocÃª ganhou "${abt}" em xp por ter ganhado o jogo da velhağŸ‰...*_`)      
fs.unlinkSync(`./armor/tictactoe/db/${from}.json`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./datab/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs)) 
joguinhodavelhajs2.splice([])
fs.writeFileSync('./datab/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
} else {
const chatMove = `*ğŸ®á€Ì¸áªÌ¸á·Ì¸á¬Ì¸ á Ì¸áªÌ¸ á™Ì¸á¬Ì¸áÌ¸á»Ì¸áªÌ¸ğŸ•¹ï¸*
          
âŒ : @${moving.X}
â­• : @${moving.O}

Sua vez : @${moving.turn == "X" ? moving.X : moving.O}

${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}
${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}
${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}
`;
conn.sendMessage(from, {text: chatMove}, {quoted: info,
contextInfo: {
mentionedJid: [
moving.X + "@s.whatsapp.net",
moving.O + "@s.whatsapp.net",
],
},
});
}
} 
} 
}


//=================================\\

async function AntilinkHardF() {
if(isUrl(body) && isAntiLinkHard && isGroupAdmins && isBotGroupAdmins) {
linkgpp = await conn.groupInviteCode(from)
if(!isUrl(body)) return 
if(budy.match(`${linkgpp}`)) return 
if(isBot) return 
reply('*Link detectado, porÃ©m usuÃ¡rio Ã© admin*')
}

if(isUrl(body) && isAntiLinkHard && !isGroupAdmins && isBotGroupAdmins) {
linkgpp = await conn.groupInviteCode(from)
if(budy.match(`${linkgpp}`)) return reply('Link do nosso grupo, nÃ£o irei remover.. ')  
if(!isUrl(body)) return 
reply('*Link detectado, punindo usuÃ¡rio...*')
conn.groupParticipantsUpdate(from, [sender], 'remove')
}
} 
AntilinkHardF()
joguinhodavelha()

if(isUrl(body) && isAntilinkgp && isGroup && isBotGroupAdmins) {
if(!isAntilinkgp) return
if(!isUrl(body)) return 
if(isGroupAdmins) return reply("VocÃª Ã© adm, nÃ£o removerei vocÃª..") 
if(budy.includes("chat.whatsapp.com/")){
if(!budy.includes("chat.whatsapp.com/")) return
if(isBot) return 
linkgpp = await conn.groupInviteCode(from)
if(budy.match(`${linkgpp}`)) return reply('Link do nosso grupo, nÃ£o irei remover.. ')  
reply('*Link de grupo detectado, punindo usuÃ¡rio...*')
conn.groupParticipantsUpdate(from, [sender], 'remove')
}
}

//========(CONTADOR-DE-MENSAGENS)========\\

const groupIdscount = []
const numbersIds = []
for(let obj of countMessage) {
groupIdscount.push(obj.groupId)
}
if(isGroup && groupIdscount.indexOf(from) >= 0) {
var ind = groupIdscount.indexOf(from)
for(let obj of countMessage[ind].numbers) {numbersIds.push(obj.id)}
if(numbersIds.indexOf(sender) >=0) {
var indnum = numbersIds.indexOf(sender)
countMessage[ind].numbers[indnum].messages += 1
countMessage[ind].numbers[indnum].cmd_messages += isCmd ? 1 : 0
fs.writeFileSync('./datab/grupos/countmsg.json', JSON.stringify(countMessage, null, 2)+ '\n')
} else {
const messages = 1
const cmd_messages = isCmd ? 1 : 0
countMessage[ind].numbers.push({
id: sender,
messages: messages,
cmd_messages: cmd_messages
})
fs.writeFileSync('./datab/grupos/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n')
}
} else if(isGroup) {
countMessage.push({
groupId: from,
numbers: [{
id: sender,
messages: 2,
cmd_messages: isCmd ? 1 : 0
}]
})
fs.writeFileSync('./datab/grupos/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n')
}
//======================================\\

//===============(AUTO-BAN)=============\\
const dbids = []
for(i=0;i<adeuscara.length;++i) {
dbids.push(adeuscara[i].groupId)
}
const isAdeusCara = (isGroup && dbids.indexOf(from) >= 0) ? true : false

//======================================\\


//============(EVAL-EXECUÃ‡Ã•ES)===========\\

if (budy.startsWith('>')){
try {
if(!SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe && !issupre && !ischyt) return
console.log('[', color('EVAL', 'silver'),']', color(moment(info.messageTimestamp * 1000).format('DD/MM HH:mm:ss'), 'yellow'), color(budy))

return reply(JSON.stringify(eval(budy.slice(2)),null,'\t')) 
} catch (e){
reply(e)
}
}

if (budy.startsWith('=>')){
try {
if (!SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe && !issupre && !ischyt) return 
var konsol = budy.slice(3)
Return = (sul) => {
var sat = JSON.stringify(sul, null, 2)
bang = util.format(sat)
if (sat == undefined){
bang = util.format(sul)
}
return reply(bang)
}

reply(util.format(eval(`;(async () => { ${konsol} })()`)))
console.log('\x1b[1;37m>', '[', '\x1b[1;32mEXEC\x1b[1;37m', ']', time, color(">", "green"), 'from', color(sender.split('@')[0]), 'args :', color(args.length))
} catch (e) {
reply(String(e))  
}
}


if (body.startsWith('$')) {
if(!SoDono && !isnit) return 
if (!q && !SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe) return
exec(q, (err, stdout) => {
if(err) return reply(`${err}`)
if (stdout) {
reply(stdout)
}
})
}

//======================================\\


//======(ANTI-IMAGEM)========\\
if(isAntiImg && isBotGroupAdmins && type == 'imageMessage') {
if (info.key.fromMe) return
if(isGroupAdmins) return conn.sendMessage(from, {text:'*mensagem proibida detectada, porÃ©m Ã© admin logo a puniÃ§Ã£o serÃ¡ anulada*'}, {quoted: info})
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}

//======(ANTI-STICKER)========\\
if(isAntiSticker && isBotGroupAdmins && type == 'stickerMessage') {
if (info.key.fromMe) return
if(isGroupAdmins) return conn.sendMessage(from, {text:'*mensagem proibida detectada, porÃ©m Ã© admin logo a puniÃ§Ã£o serÃ¡ anulada*'}, {quoted: info})
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}

if(Antidoc && isBotGroupAdmins && type == 'documentMessage') {
if (info.key.fromMe) return
if(isGroupAdmins) return conn.sendMessage(from, {text:'*mensagem proibida detectada, porÃ©m Ã© admin logo a puniÃ§Ã£o serÃ¡ anulada*'}, {quoted: info})
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}

// ANTI NOTAS FAKES ======================>

if(isAntiNotas && bady.toString().match(/(ğŸ’³|ğŸ’|ğŸ’¸|ğŸ’µ|ğŸ’·|ğŸ’¶|ğŸª™|ğŸ’°|ğŸ¤‘|âš–ï¸)/gi) && isBotGroupAdmins) {
if(type == 'stickerMessage') return
let verificar = bady.toString().match(/(ğŸ’³|ğŸ’|ğŸ’¸|ğŸ’µ|ğŸ’·|ğŸ’¶|ğŸª™|ğŸ’°|ğŸ¤‘|âš–ï¸)/gi)
if (verificar && bady.length < 100) return  
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}

//FINALZIN ==============================>


//======(ANTI-VIDEO)========\\
if(isAntiVid && isBotGroupAdmins && type == 'videoMessage') {
if(isGroupAdmins) return conn.sendMessage(from,{text:'*mensagem proibida detectada, porÃ©m Ã© admin logo a puniÃ§Ã£o serÃ¡ anulada*'}, {quoted: info})
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}

//======(ANTI-AUDIO)=======\\
if(isAntiAudio && isBotGroupAdmins && type == 'audioMessage') {
if(isGroupAdmins) return conn.sendMessage(from, {text:'*mensagem proibida detectada, porÃ©m Ã© admin logo a puniÃ§Ã£o serÃ¡ anulada*'}, {quoted: info})
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}
//=======================================\\



//========(ANTI-PV-QUE-BLOQUEIA)======\\
if(isAntiPv && !isGroup && !SoDono && !isnit && !isPremium){ 
	reply('*Antipv ativado, vocÃª serÃ¡ bloqueado!*\n*Contate o criador*')
delay(4000)
conn.updateBlockStatus(sender, 'block')
return
}
//======================================\\


//=========(ANTIPV-QUE-SÃ“-FALA)==========\\

if(!isGroup && !isPremium && !SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe && banChats === true) return reply(`OlÃ¡, sou uma inteligÃªncia artificial, programado(a) para realizar aÃ§Ãµes, por adms e o dono, se vocÃª estÃ¡ enviando mensagem, provavelmente vocÃª nÃ£o sabe disso, eu removo diariamente pessoas por enviar links e muito mais..`)
const atibot = info.isBaileys
if (atibot === true) return 


//======================================\\

// ANTI_LIGAR \\

if(isAnticall) {
conn.ws.on('CB:call', async (B) => {
if (B.content[0].tag == 'offer') {
conn.sendMessage(B.content[0].attrs['call-creator'], { text: "NÃ£o pode ligar para o bot, vocÃª serÃ¡ bloqueado.." }).then(() => { 
delay(4000)
conn.updateBlockStatus(B.content[0].attrs['call-creator'], "block") })
}
})
}

//==SISTEMA DE VOTAÃ‡ÃƒO: CRÃ‰DITOS: KAUAN==\\
if(isGroup) {
if (budy.toLowerCase() === 'voto'){
let vote = JSON.parse(fs.readFileSync(`./armor/${from}.json`))
let _votes = JSON.parse(fs.readFileSync(`./armor/vote/${from}.json`))  
let fil = vote.map(v => v.participant)
let id_vote = sender ? sender : '0@s.whatsapp.net'
if(fil.includes(id_vote)) {
return mentions('@'+sender.split('@')[0]+' nÃ£o Ã© possivel votar duas vezes', fil, true)
} else {
vote.push({
participant: id_vote,
voting: 'âœ…'
})
fs.writeFileSync(`./armor/${from}.json`,JSON.stringify(vote))
let _p = []
let _vote = '*Vote* '+ '@'+ _votes[0].votes.split('@')[0] + `\n\n*para*: ${_votes[0].reason}\n*total Votos* : ${vote.length} Votos\n*DuraÃ§Ã£o* : ${_votes[0].durasi} minutos\n\n` 
for(let i = 0; i < vote.length; i++) {
_vote +=  `@${vote[i].participant.split('@')[0]}\n*Vote* : ${vote[i].voting}\n\n`
_p.push(vote[i].participant)
        }  
_p.push(_votes[0].votes)
mentions(_vote,_p,true)   
}
} else if (budy.toLowerCase() === 'devoto'){
const vote = JSON.parse(fs.readFileSync(`./armor/${from}.json`))
let _votes = JSON.parse(fs.readFileSync(`./armor/vote/${from}.json`))  
let fil = vote.map(v => v.participant)
let id_vote = sender ? sender : '0@s.whatsapp.net'
if(fil.includes(id_vote)) {
return mentions('@'+sender.split('@')[0]+' nÃ£o Ã© possivel anular um voto', fil, true)
} else {
vote.push({
participant: id_vote,
voting: 'âŒ'
})
fs.writeFileSync(`./armor/${from}.json`,JSON.stringify(vote))
let _p = []
let _vote = '*Vote* '+ '@'+ _votes[0].votes.split('@')[0] + `\n\n*para*: ${_votes[0].reason}\n*total Votos* : ${vote.length} Vote\n*duraÃ§Ã£o* : ${_votes[0].durasi} minutos\n\n` 
for(let i = 0; i < vote.length; i++) {
_vote +=  `@${vote[i].participant.split('@')[0]}\n*Vote* : ${vote[i].voting}\n\n`
_p.push(vote[i].participant)
}  
_p.push(_votes[0].votes)
mentions(_vote,_p,true)   
}
}
}	
//======================================\\


//_CONTAGEM DE COMANDOS
if (isCmd) cmdadd()
            
if (isBanned) return
BannedExpired(ban)

if (isCmd && !SoDono && !isnit && !issupre && !ischyt) addFilter(sender)


switch (figura) {
  
case 'PhBL0PtpQ7pESrESQNgLuXpPJfhblay8ykTUfOH3xpRXYw=':
bla = fs.readFileSync('./audios/qviado.mp3')
conn.sendMessage(from, {audio: bla, mimetype: 'audio/mp4', ptt:true}, {quoted:info})
break
}

//INICIO DE COMANDO DE PREFIXO
switch(command) {
  
//=========(-MENUS-DE-CMDS-)========\\
case 'menu': case 'comandos': case 'help':
sendBimgT(from, `${logo}`, menu(prefix, NomeDoBot), "Leia com AtenÃ§Ã£o", [{index: 1, urlButton: {displayText: 'GIT DO BOT', url: 'https://github.com/NuevaGeneracionALB/aleatory-md.git'}},
 {index: 2, callButton: {displayText: 'LigaÃ§Ã£o', phoneNumber: '190'}},
{index: 2, quickReplyButton: {displayText: 'ğŸ’¥ MENU DE LOGOS COM EFT âš¡', id: `${prefix}menulogos`}},
{index: 2, quickReplyButton: {displayText: 'â˜‚ï¸ MENU ADMNISTRADORES â˜”', id: `${prefix}menuadm`}}, 
{index: 3, quickReplyButton: {displayText: 'âš“ LISTA DE BRINCADEIRAS âš“', id: `${prefix}brincadeiras`}}], selo)
break

case 'menu':
case 'help':
case 'comandos':
sendBimg(from, `${logo}`, menu(prefix, NomeDoBot), "Leia com atenÃ§Ã£o", [
{buttonId: `${prefix}brincadeiras`, buttonText: {displayText: `ğŸ¤¡ MENU DE BRINCADEIRAS ğŸ¤¡`}, type: 1}, {buttonId: `${prefix}logos`, buttonText: {displayText: `ğŸ’¥ MENU DE LOGOS âš¡`}, type: 1}, {buttonId: `${prefix}infodono`, buttonText: {displayText: `ğŸ”¸ INFORMAÃ‡Ã•ES DO DONO ğŸ”¸`}, type: 1}], selo) 
break 

case 'logos':
case 'menulogo':
case 'menulogos':  
sendBimg(from, `${logo}`, menulogos(prefix), "Leia com atenÃ§Ã£o", [
{buttonId: `${prefix}brincadeiras`, buttonText: {displayText: `ğŸ¤¡ MENU DE BRINCADEIRAS ğŸ¤¡`}, type: 1}, {buttonId: `${prefix}alteradores`, buttonText: {displayText: `ğŸ’¥ ALTERADORES DE AUDIO/V âš¡`}, type: 1}, {buttonId: `${prefix}efeitosimg`, buttonText: {displayText: `ğŸ”¸ EFEITOS DE IMAGEM ğŸ”¸`}, type: 1}], selo)
break 

case 'menuadm':
case 'menuadms':
case 'adm':  
sendBimg(from, `${logo}`, adms(prefix), `â˜‚ï¸`, [
{buttonId: `${prefix}infobot`, buttonText: {displayText: `â™¦ï¸ ÃUDIO DE INFORMAR SOBRE O DONO â™£ï¸`}, type: 1}, {buttonId: `${prefix}infodono`, buttonText: {displayText: `ğŸ’¥ INFORMAÃ‡Ã•ES DO DONOâš¡`}, type: 1}], selo) 
break 

case 'menudono':
case 'donomenu':  
sendBimg(from, `${logo}`, menudono(prefix), `â˜”`, [
{buttonId: `${prefix}infobot`, buttonText: {displayText: `â™¦ï¸ ÃUDIO DE INFORMAR SOBRE O DONO â™£ï¸`}, type: 1}, {buttonId: `${prefix}infodono`, buttonText: {displayText: `ğŸ’¥ INFORMAÃ‡Ã•ES DO DONOâš¡`}, type: 1}], selo) 
break 

case 'efeitosimg':
case 'efeitos':  
case 'efeitoimg':
case 'efeitosmarcar':  
sendBimg(from, `${logo}`, efeitos(prefix), `ğŸŒ€`, [
{buttonId: `${prefix}brincadeiras`, buttonText: {displayText: `ğŸ¤¡ MENU DE BRINCADEIRAS ğŸ¤¡`}, type: 1}, {buttonId: `${prefix}acodee`, buttonText: {displayText: `ğŸ’¥ MENU DE LOGOS âš¡`}, type: 1}, {buttonId: `${prefix}menu`, buttonText: {displayText: `ğŸ”¸ MENU ğŸ”¸`}, type: 1}], selo)
break 

case 'owner':
case 'odono':
case 'dono': 
case 'infodono':  
numerodn = setting.numerodono 
wew = await getBuffer(`${logo}`) 
await conn.sendMessage(from, {image: wew, caption: infodono(prefix, numerodn, NomeDoBot)}, {quoted: selo})
break 

case 'alteradores':  
wew = await getBuffer(`${logo}`) 
await conn.sendMessage(from, {image: wew, caption: alteradores(prefix)}, {quoted: selo})
break 

case 'brincadeiras':
case 'brincadeira':
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`) 
wew = await getBuffer(`${logo}`) 
await conn.sendMessage(from, {image: wew, caption: brincadeiras(prefix)}, {quoted: selo})
break 

case 'menupremium':
case 'menuprem':
await conn.sendMessage(from, {text: menuprem(prefix)}, {quoted: selo})
break

case 'configurar-bot':
await conn.sendMessage(from, {text: configbot(prefix)}, {quoted: selo})
break

case 'comandos-termux':
await conn.sendMessage(from, {text: cmd_termux(prefix)}, {quoted: selo})
break

case 'hospedar-heroku':
await conn.sendMessage(from, {text: hospedar(prefix)}, {quoted: selo})
break

case 'destrava':
if (!isPremium && !isGroupAdmins) return reply(enviar.msg.premium)
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: info})
break 

case 'perfil':
try {
ppimg = await conn.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
} catch {
ppimg = 'https://i0.wp.com/www.gambarunik.id/wp-content/uploads/2019/06/Top-Gambar-Foto-Profil-Kosong-Lucu-Tergokil-.jpg'
}

var conselho = palavras[Math.floor(Math.random() * palavras.length)]
const nivelgado = ['1','2','3','4','5','6','7','8','9']
const nivelgado2 = ['1','2','3','4','5','6','7','8','9'] 
const nivelgador = nivelgado[Math.floor(Math.random() * (nivelgado.length))]
const nivelgado2r = nivelgado2[Math.floor(Math.random() * (nivelgado2.length))] 
const puta = ['1','2','3','4','5','6','7','8','9']
const puta2 = ['1','2','3','4','5','6','7','8','9'] 
const putar = puta[Math.floor(Math.random() * (puta.length))]
const putar2 = puta2[Math.floor(Math.random() * (puta2.length))] 
const gostosura = ['1','2','3','4','5','6','7','8','9']
const gostosura2 = ['1','2','3','4','5','6','7','8','9'] 
const gostosurar = gostosura[Math.floor(Math.random() * (gostosura.length))]
const gostosurar2 = gostosura2[Math.floor(Math.random() * (gostosura2.length))] 
gadop = `${Math.floor(Math.random() * 100)}`
const programa = Math.ceil(Math.random() * 10000)
const asLvl = getLevelingLevel(sender)
const ssXp = getLevelingXp(sender)
const dptr = `     ã€Œ ğŸ”¥ ~_*PERFIL*_~ ğŸŒˆ ã€
ğŸ—’ *Nome* : *${pushname}*
ğŸª€ *NÃºmero* : @${sender.split("@")[0]}
ğŸ‚ *NÃ­vel gado* : *${nivelgador}${nivelgado2r}%*
ğŸ“± *Seu CÃ©lular* : ${info.key.id.length > 21 ? 'Android ğŸ¤£' : info.key.id.substring(0, 2) == '3A' ? 'IOSğŸ˜‚ğŸ˜‚ğŸ˜…' : 'Zap zap web ğŸ˜‚ğŸ˜‚â˜ğŸ¼ğŸ˜…'}
ğŸ˜ˆ *NÃ­vel puta* : *${putar}${putar2}%*
ğŸ˜‹ *NÃ­vel de gostosura* : *${gostosurar}${gostosurar2}%*
ğŸ¼ *Valor do programa* : *R$${programa}*

â» *~_CONSELHO_~* :
${conselho}`
if(verificado === true) { 
daftarimg = await getBuffer(ppimg)
conn.sendMessage(from, {image: daftarimg, caption: dptr}, {quoted: selo})
} else {
daftarimg = await getBuffer(ppimg)
conn.sendMessage(from, {image: daftarimg, caption: dptr}, {quoted: info})  
}
break

case 'frases':
case 'frase':
try {
ppimg = await conn.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
} catch {
ppimg = 'https://i0.wp.com/www.gambarunik.id/wp-content/uploads/2019/06/Top-Gambar-Foto-Profil-Kosong-Lucu-Tergokil-.jpg'
}

hehe = await fetchJson(`https://www.luc4rio-rest-api.tk/api/aleatorios/frases`)
if (hehe.error) return reply(hehe.error)
ccg =
`
  â€£ Author: ${hehe.Author}
 
  â€£ Criador: ${hehe.Criador}
 
  â€£ Frase: 
 
  ${hehe.Frase}\n`
daftarimg = await getBuffer(ppimg)
await conn.sendMessage(from, {image: daftarimg, caption: ccg}, {quoted:info})
break

case 'conselhobiblico':
case 'conselhosbiblico':  
case 'conselhosb':   
case 'conselhob':  
var conselhosb = conselhob[Math.floor(Math.random() * conselhob.length)]   
jr = `${tempo} ${pushname} 

Conselhos BÃ­blico para vocÃª: 

- ${conselhosb} 

> Bot: ${NomeDoBot}
> Grupo: ${groupName}`
await conn.sendMessage(from, {text: jr}, {quoted:info, contextInfo: {"mentionedJid": jr}})
break

case 'tabela':
if(verificado === true) {
await conn.sendMessage(from, {text: tabela(prefix, NomeDoBot)}, {quoted: selo})
} else {
await conn.sendMessage(from, {text: tabela(prefix, NomeDoBot)}, {quoted: info})  
}
break 

case 'destrava2':
if (!isPremium && !isGroupAdmins) return reply(enviar.msg.premium)
await conn.sendMessage(from, {text: destrava2 (prefix)}, {quoted: info})
break 

case 'infovotaÃ§Ã£o':
case 'infovotacao':  
if(verificado === true) {  
await conn.sendMessage(from, {text: infovotacao(prefix, pushname)}, {quoted: selo})
} else {
await conn.sendMessage(from, {text: infovotacao(prefix, pushname)}, {quoted: info})  
}
break

case 'infobemvindo':
case 'infobv':  
if(verificado === true) {   
await conn.sendMessage(from, {text: infobemvindo(prefix)}, {quoted: selo})
} else {
await conn.sendMessage(from, {text: infobemvindo(prefix)}, {quoted: info})  
}
break

case 'idiomas':
case 'idioma':
txt = `  
IDIOMAS DO GTTS OU DO TRADUTOR

EXEMPLO :

>> ${prefix}gtts pt (texto)

>> ${prefix}traduzir pt/(texto)

o PT que coloquei, Ã© a linguagem, entÃ£o pode por no lugar as 2 letras que define a linguagem, iguais os exemplos e os idiomas abaixo.

'af': 'Afrikaans',
'sq': 'Albanian',
'ar': 'Arabic',
'hy': 'Armenian',
'ca': 'Catalan',
'hr': 'Croatian',
'cs': 'Czech',
'da': 'Danish',
'nl': 'Dutch',
'en': 'English',
'eo': 'Esperanto',
'fi': 'Finnish',
'fr': 'French',
'de': 'German',
'el': 'Greek',
'ht': 'Haitian Creole',
'hi': 'Hindi',
'hu': 'Hungarian',
'is': 'Icelandic',
'id': 'Indonesian',
'it': 'Italian',
'ja': 'Japanese',
'ko': 'Korean',
'la': 'Latin',
'lv': 'Latvian',
'mk': 'Macedonian',
'no': 'Norwegian',
'pl': 'Polish',
'pt': 'Portugues',
'ro': 'Romanian',
'ru': 'Russian',
'sr': 'Serbian',
'sk': 'Slovak',
'es': 'Spanish',
'sw': 'Swahili',
'sv': 'Swedish',
'ta': 'Tamil',
'th': 'Thai',
'tr': 'Turkish',
'vi': 'Vietnamese',
'cy': 'Welsh'
 
ğŸ”¥${setting.NomeDoBot}ğŸ”¥`

if(verificado === true) { 
conn.sendMessage(from, {text: txt}, {quoted: selo})
} else {
conn.sendMessage(from, {text: txt}, {quoted: selo})  
}
break

case 'infocontador':
if(verificado === true) {   
await conn.sendMessage(from, {text: infocontador(prefix, pushname)}, {quoted: selo})
} else {
await conn.sendMessage(from, {text: infocontador(prefix, pushname)}, {quoted: info})  
}
break

case 'databoton':
if(verificado === true) {  
await conn.sendMessage(from, {text: databoton(prefix)}, {quoted: selo})
} else {
await conn.sendMessage(from, {text: databoton(prefix)}, {quoted: info})  
}
break

case 'infolistanegra':
if(verificado === true) {
await conn.sendMessage(from, {text: infolistanegra(prefix, pushname)}, {quoted: selo})
} else {
await conn.sendMessage(from, {text: infolistanegra(prefix, pushname)}, {quoted: info})  
}
break

case 'infopalavrÃ£o':
case 'infopalavrao':
if(verificado === true) {
await conn.sendMessage(from, {text: infopalavrao(prefix, pushname)}, {quoted: selo})
} else {
await conn.sendMessage(from, {text: infopalavrao(prefix, pushname)}, {quoted: info})  
}
break

case 'infobancarac':
if(verificado === true) {
await conn.sendMessage(from, {text: infobancarac(prefix, pushname)}, {quoted: selo})
} else {
await conn.sendMessage(from, {text: infobancarac(prefix, pushname)}, {quoted: info})  
}
break

case 'git':
case 'git-bot':  
case 'gitdobot':
case 'gitbot':   
if(verificado === true) {
await conn.sendMessage(from, {text: gitdobot(prefix)}, {quoted: selo})
} else {
await conn.sendMessage(from, {text: gitdobot(prefix)}, {quoted: info})  
}
break

//========(FUNÃ‡Ã•ES-PREMIUM-AQUI)=======\\

case 'mediafire':
txt = args.join(" ")
if(!txt) return reply('Cade o Link?')
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/mediafire?url=${txt}&&apikey=${keyale}`)
reply(`*Enviando o Arquivo: ${bla.resultado[0].nama}\nPeso: ${bla.resultado[0].size}`)
blabla = await getBuffer(bla.resultado[0].link)
blabla1 = await getBuffer(bla.resultado[0].mime)
blabla2 = await getBuffer(bla.resultado[0].nama)
conn.sendMessage(from, {document:  blabla, mimetype: blabla1, fileName: blabla2}, {quoted: info}).catch(e => {
reply('ERROR')
})
break

case 'ler': 
case 'ocr':   
case 'lerfoto':  
if(!isPremium) return reply(enviar.msg.premium)
if ((isMedia && !info.message.videoMessage || isQuotedImage) && args.length == 0) {
encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
media = rane 
reply(enviar.espere)
await recognize(media, {lang: 'eng+ind', oem: 1, psm: 3})
.then(teks => {
reply(teks.trim())
fs.unlinkSync(media)
})
.catch(err => {
reply(err.message)
fs.unlinkSync(media)
})
} else {
reply('Somente fotos!')
}
break

case 'premiumlist':
if(!isPremium) return reply(enviar.msg.premium)   
tkks = 'â•­â”€â”€â”€â”€*ã€Œ *PREMIUM USERğŸ‘‘* ã€\n'
for (let V of premium) {
tkks += `â”‚+  @${V.split('@')[0]}\n`
}
tkks += `â”‚+ Total : ${premium.length}\nâ•°â”€â”€â”€â”€â”€â”€*ã€Œ *${setting.NomeDoBot}* ã€*â”€â”€â”€â”€`
reply(tkks.trim())
break

case 'getquoted':
case 'getinfo':  
case 'get':  
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo, null, 3))
break

case 'id':
case 'figuid':
if (!SoDono && !info.key.fromMe) return 
if (isQuotedSticker) {
var figu = info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage.fileSha256.toString("base64");
reply(figu)
}
break

case 'gerarcpf':
if(!isPremium) return reply(enviar.msg.premium)
cp1 = `${Math.floor(Math.random() * 300) + 600}`
cp2 = `${Math.floor(Math.random() * 300) + 600}`
cp3 = `${Math.floor(Math.random() * 300) + 600}`
cp4 = `${Math.floor(Math.random() * 30) + 60}`
cpf = `${cp1}.${cp2}.${cp3}-${cp4}`
await conn.sendMessage(from, {text: `CPF gerado com sucesso : ${cpf}`}, {quoted: info})
break

case 'cep':
if(!isPremium) return reply(enviar.msg.premium)  
if (args.length == 0) return reply(`Exemplo: ${prefix + command} 54330235`)
query = args.join(" ")
get_result = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/tools/cep?apikey=apiteam&cep=${query}`)
x = get_result.resultado
k = `CEP : ${x.cep}
LOGRADOURO: ${x.logradouro}
BAIRRO : ${x.bairro}
LOCALIDADE : ${x.localidade}
UF : ${x.uf}
IBGE : ${x.ibge}
GIA : ${x.gia}
DDD : ${x.ddd}
SIAFI : ${x.siafi}`
reply(k)
break 

case 'placa':
if(!isPremium) return reply(enviar.msg.premium)  
if (args.length == 0) return reply(`Exemplo: ${prefix + command} 54330235`)
query = args.join(" ")
get_result = await fetchJson(`http://api.ifindconsultas.tk/?token=2d6de38e-6c92-485e-bacb-db64139f8a02&placa=${query}`)
x = get_result
k = `CPF : ${x.cpf}
NOME: ${x.nome}
PLACA : ${x.placa}
CHASSI : ${x.chassi}
RENAVAM : ${x.renavam}
CIDADE : ${x.cidade}
UF : ${x.uf}
CATEGORIA : ${x.categoria}
COMBUSTÃVEL : ${x.combustivel}`
reply(k)
break 

case 'ddd':
if(!isPremium) return reply(enviar.msg.premium)
if (args.length < 1) return reply(`Use ${prefix + command} 81`)
ddd = body.slice(5)
ddds = await axios.get(`https://brasilapi.com.br/api/ddd/v1/${ddd}`)
dddlist = `Lista de Cidades de ${ddds.data.state} com este DDD ${q}>\n\n`
for (let i = 0; i < ddds.data.cities.length; i++) { dddlist += `${i + 1} âª§ *${ddds.data.cities[i]}*\n` }
conn.sendMessage(from, {text: dddlist}, {quoted: info})	
break

case 'encurtalink':
if(!isPremium) return reply(enviar.msg.premium)
if(args.length < 1) return reply(`Exemplo:\n${prefix}encurtalink https://youtube.com/c/aleatoryconteudos`)
try {
link = args[0]
anu = await axios.get(`https://tinyurl.com/api-create.php?url=${link}`)
reply(`${anu.data}`)
} catch (e) {
emror = String(e)
reply(`${e}`)
}
await limitAdd(sender)
break

//===========(ADMS-FUNÃ‡Ã•ES-AKI)=========\\

case 'calculadora':
case 'calcular':  
case 'calc':
teks = args.join(" ")
if(!body.includes('1') && !body.includes('2') && !body.includes('3') && !body.includes('4') && !body.includes('5') && !body.includes('6') && !body.includes('7') && !body.includes('8') && !body.includes('9') && !body.includes('10')) return reply('KD O NÃšMERO?')
if(body.includes("document") || body.includes("audio") || body.includes("pdf") || body.includes("apk") || body.includes("image") || body.includes("video") || body.includes("text") || body.includes("conn") || body.includes("reply") || body.includes("console") || body.includes("'") || body.includes('"')) return reply("KD O CÃLCULO?")
console.log('[', color('EVAL', 'silver'),']', color(moment(info.messageTimestamp * 1000).format('DD/MM HH:mm:ss'), 'yellow'), color(budy))
return reply(JSON.stringify(eval(`${teks}`),null,'\t'))
break 

case 'status':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins && !SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.adm)
statuszada =
`â•­â•¼â•¼â•¾â² S T A T U S â³â•¼â•¼â•¾â•®
â”‚
â”‚â± Antiaudio: ${isAntiAudio? 'âœ“' : 'âœ•'}
â”‚â± Antidocumento: ${Antidoc ? 'âœ“' : 'âœ•'}
â”‚â± Antifake: ${isAntifake ? 'âœ“' : 'âœ•'}
â”‚â± Antiimg: ${isAntiImg? 'âœ“' : 'âœ•'}
â”‚â± AntiSticker: ${isAntiSticker ? 'âœ“' : 'âœ•'}
â”‚â± Antilink: ${isAntiLink ? 'âœ“' : 'âœ•'}
â”‚â± AntiligaÃ§Ã£o: ${isAnticall ? 'âœ“' : 'âœ•'}
â”‚â± AntiPv-Block: ${isAntiPv ? 'âœ“' : 'âœ•'}
â”‚â± AntilinkHard: ${isAntiLinkHard ? 'âœ“' : 'âœ•'}
â”‚â± LimiteCaracteres: ${isAntiFlood ? 'âœ“' : 'âœ•'}
â”‚â± AntiPalavrÃ£o: ${isPalavrao ? 'âœ“' : 'âœ•'}
â”‚â± Antivideo: ${isAntiVid ? 'âœ“' : 'âœ•'}
â”‚â± AntiLocalizaÃ§Ã£o: ${Antiloc ? 'âœ“' : 'âœ•'}
â”‚â± Bemvindo: ${isWelkom ? 'âœ“' : 'âœ•'}
â”‚â± Simih: ${isSimi ? 'âœ“' : 'âœ•'}
â”‚â± Modo brincadeira: ${isModobn ? 'âœ“' : 'âœ•'}
â”‚
â•°â•¼â•¾â² ${NomeDoBot} â³â•¼â•¾â•¯`
if(gifmenu === false) {
wew = await getBuffer(`${logo}`)
conn.sendMessage(from, {image: wew, caption: statuszada, thumbnail: null})
} else {
wew = await getBuffer(`${logo}`)
conn.sendMessage(from, {video: wew, caption: statuszada, gifPlayback: true})  
}
break

case 'nomegp':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
blat = args.join(" ")
conn.groupUpdateSubject(from, `${blat}`)
conn.sendMessage(from, {text: 'Sucesso, alterou o nome do grupo'}, {quoted: info})
break

case 'descgp':
case 'descriÃ§Ã£ogp':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.adm)
blabla = args.join(" ")
conn.groupUpdateDescription(from, `${blabla}`)
conn.sendMessage(from, {text: 'Sucesso, alterou a descriÃ§Ã£o do grupo'}, {quoted: info})
break

case 'setfotogp':
case 'fotogp':  
addFilter(from)
if (!isGroup) return reply('SÃ³ pode ser utilizado em Grupo')
if (!isGroupAdmins) return reply('VocÃª precisa ser ADM')
if (!isBotGroupAdmins) return reply('O bot Precisa ser ADM')
if (!isQuotedImage) return reply(`Use: ${prefix + command} <Marque uma foto>`)
ftgp = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(ftgp.mimetype))
buffimg = await getFileBuffer(ftgp, 'image')
fs.writeFileSync(rane, buffimg)
medipp = rane 
await conn.updateProfilePicture(from, {url: medipp})
reply(`Foto do grupo alterada com sucesso`) 
break

case 'atividade':
case 'atividades':  
try{
if(!isGroupAdmins && !issupre && !ischyt) return reply(enviar.msg.adm)
if(isGroup && groupIdscount.indexOf(from) >= 0) {
var ind = groupIdscount.indexOf(from)
teks = `*Atividade dos membros do grupo:*\n\n`
mem = []
for(let obj of groupMembers) {
if(numbersIds.indexOf(obj.id) >=0) {
var indnum = numbersIds.indexOf(obj.id)
teks += `*â€¢ Membro:* @${countMessage[ind].numbers[indnum].id.split('@')[0]}\n*â€¢ Comandos:* ${countMessage[ind].numbers[indnum].cmd_messages}\n*â€¢ Mensagens:* ${countMessage[ind].numbers[indnum].messages}\n\n----------------------------------\n\n`
} else {
teks += `*â€¢ Membro:* @${obj.id.split('@')[0]}\n*â€¢ Comandos:* 0\n*â€¢ Mensagens:* 0\n\n----------------------------------\n\n`
}
mem.push(obj.id)
}
conn.sendMessage(from, {text: teks, contextInfo:{mentionedJid: mem}}, {quoted: info})
} else return reply('*Nada foi encontrado*')
} catch (e){
console.log(e)
}
break

case 'linkgp':
case 'linkgroup':
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isGroup) return reply(enviar.msg.grupo)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
linkgc = await conn.groupInviteCode(from)
reply('https://chat.whatsapp.com/'+linkgc)
break

case 'grupo': 
if (!isGroup) return reply(`SÃ“ EM GRUPO`)
if (!isGroupAdmins) return reply(`PRECISA SER ADMININASTROR`)
if (!isBotGroupAdmins) return reply(`BOT PREPRECISA SER ADMININASTROR`)
if (args[0] === 'a') {
reply(`*GRUPO ABERTO COM SUCESSO*`)
await conn.groupSettingUpdate(from, 'not_announcement')
} else if (args[0] === 'f') {
reply(`*GRUPO FECHADO COM SUCESSO*`)
await conn.groupSettingUpdate(from, 'announcement')
}				 
break 

case 'grupoinfo':
case 'infogrupo':
case 'infogp':  
case 'gpinfo':  
case 'regras':  
if (!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins)return reply(enviar.msg.adm)
ppUrl = await conn.profilePictureUrl(from, 'image')
buffer = await getBuffer(ppUrl)
const metadata = await conn.groupMetadata(from) 
conn.sendMessage(from, {image: buffer, caption: `*NOME* : ${groupName}\n*MEMBRO* : ${groupMembers.length}\n*ADMIN* : ${groupAdmins.length}\n*DESCRIÃ‡ÃƒO* : ${metadata.desc}`, thumbnail: null}, {quoted: info})
break 

case 'hidetag':
if (!isGroup) return reply('Este comando sÃ³ deve ser utilizado em Grupo.')
if(!isGroupAdmins) return reply('VocÃª precisa ser ADM pra utilizar este comando')
value = body.slice(9)
group = await conn.groupMetadata(from)
member = group['participants']
mem = []
member.map( async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
options = {
text: value,
mentions: mem,
quoted: info
}
conn.sendMessage(from, options)
break

case 'totag':
if(!isGroupAdmins) return reply(enviar.msg.adm)
if ((isMedia && !info.message.videoMessage || isQuotedSticker) && args.length == 0) {
encmedia = isQuotedSticker ? info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage : info.message.stickerMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'sticker')
fs.writeFileSync(rane, buffimg)
file = rane 
value = args.join(" ")
var group = await conn.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
contextInfo: { mentionedJid: mem },
quoted: info
}
ini_buffer = fs.readFileSync(file)
conn.sendMessage(from, {sticker: ini_buffer}, options)
fs.unlinkSync(file)
} else if ((isMedia && !info.message.videoMessage || isQuotedImage) && args.length == 0) {
encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
file = rane 
value = args.join(" ")
var group = await conn.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
contextInfo: { mentionedJid: mem },
quoted: info
}
ini_buffer = fs.readFileSync(file)
conn.sendMessage(from, {image: ini_buffer}, options)
fs.unlinkSync(file)
} else if ((isMedia && !info.message.videoMessage || isQuotedAudio) && args.length == 0) {
encmedia = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'audio')
fs.writeFileSync(rane, buffimg)
file = rane 
value = args.join(" ")
var group = await conn.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
mimetype : 'audio/mp4', duration: 999999999,
ptt : true,
contextInfo: { mentionedJid: mem },
quoted: info
}
ini_buffer = fs.readFileSync(file)
conn.sendMessage(from, {audio: ini_buffer}, options)
fs.unlinkSync(file)
 } else if ((isMedia && !info.message.videoMessage || isQuotedVideo) && args.length == 0) {
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
file = rane 
value = args.join(" ")
var group = await conn.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
gifPlayback: true,
contextInfo: { mentionedJid: mem },
quoted: info
}
ini_buffer = fs.readFileSync(file)
conn.sendMessage(from, {video: ini_buffer}, options)
fs.unlinkSync(file)
} else if ((isMedia && !info.message.videoMessage || isQuotedDocument) && args.length == 0) {
encmedia = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'document')
fs.writeFileSync(rane, buffimg)
file = rane 
value = args.join(" ")
var group = await conn.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
mimetype : 'text/plain',
contextInfo: { mentionedJid: mem },
quoted: info
}
ini_buffer = fs.readFileSync(file)
conn.sendMessage(from, {document: ini_buffer}, options)
fs.unlinkSync(file)
}  else if ((isMedia && !info.message.videoMessage || isQuotedVideo) && args.length == 0) {
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
file = rane 
value = args.join(" ")
var group = await conn.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
mimetype : 'video/mp4', duration: 999999999,
contextInfo: { mentionedJid: mem },
quoted: info
}
ini_buffer = fs.readFileSync(file)
conn.sendMessage(from, {video: ini_buffer}, options)
fs.unlinkSync(file)
} else{
reply(`Responder imagem/documento/gif/adesivo/Ã¡udio/vÃ­deo com legenda ${prefix + command}`)
}
break

case 'marcar':
try {
if (!isGroup) return reply('Este comando sÃ³ deve ser utilizado em Grupo.')
if (!isGroupAdmins) return reply('VocÃª precisa ser ADM pra utilizar este comando')
members_id = []
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += '\n\n'
for (let mem of groupMembers) {
teks += `*#* @${mem.id.split('@')[0]}\n`
members_id.push(mem.id)
}
mentions(teks, members_id, true)
} catch {
reply('ERROR!!')
}
break

case 'marcar2':
try {
if (!isGroup) return reply('Este comando sÃ³ deve ser utilizado em Grupo.')
if (!isGroupAdmins) return reply('VocÃª precisa ser ADM pra utilizar este comando')  
members_id = []
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += '\n\n'
for (let mem of groupMembers) {
teks += `â• â¥ @${mem.id.split('@')[0]}\n`
members_id.push(mem.id)
}
reply(teks)
} catch {
reply('ERROR!!')
}
break

case 'marcarwa':
try {
if (!isGroup) return reply('Este comando sÃ³ deve ser utilizado em Grupo.')
if (!isGroupAdmins) return reply('VocÃª precisa ser ADM pra utilizar este comando')  
members_id = []
teks = (args.length > 1) ? body.slice(10).trim() : ''
teks += '\n\n'
for (let mem of groupMembers) {
teks += `â• â¥ https://wa.me/${mem.id.split('@')[0]}\n`
members_id.push(mem.id)
}
conn.sendMessage(from, {text: teks}, {quoted: info})
} catch {
reply('ERROR!!')
}
break

case 'kick':
if (!isGroup) return reply('Este comando sÃ³ deve ser utilizado em Grupo.')
if (!isGroupAdmins) return reply('VocÃª precisa ser ADM pra utilizar este comando')
if (!isBotGroupAdmins) return reply('Bot precisa ser ADM, para executar esta funÃ§Ã£o.')
tektp = args.join(" ")
if(tektp.includes(numerodono)) return reply("NÃ£o pode remover meu dono ğŸ˜¡")
if(tektp.includes(botNumber)) return reply("VocÃª acha que vou banir eu mesmo??, troxa vocÃª em..")
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque a')
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
if (mentioned.length > 1) {
teks = 'Pedidos recebidos, emitidos :\n'
for (let _ of mentioned) {
teks += `@${_.split('@')[0]}\n`
}
mentions(teks, mentioned, true)
conn.groupParticipantsUpdate(from, mentioned, 'remove')
} else {
mentions(`Pedidos recebidos, emitidos : @${mentioned[0].split('@')[0]}`, mentioned, true)
conn.groupParticipantsUpdate(from, mentioned, 'remove')
}
break

case 'reviver':
if (!isGroup) return reply('Esse comando so funciona em grupo, sinto muito')
if(!isGroupAdmins) return reply('âŒ VOCÃŠ NÃƒO Ã‰ ADM PRA UTILIZAR ESTE COMANDO, DESCULPE, QUEM SABE UM DIA ğŸ˜‚')
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque uma mensagem do alvo!')
add = info.message.extendedTextMessage.contextInfo.participant
sleep(5000)
const response2 = await conn.groupParticipantsUpdate(from, [add], "add" )
reply('Usuario Adicionado de volta ao grupo.')
break

case 'add':
if(!SoDono) return reply('Comando Desativado por questÃµes de seguranÃ§a, estava ocasionandoo Ban do nÃºmero do bot.')
if(!isGroupAdmins) return reply('âŒ VOCÃŠ NÃƒO Ã‰ ADM PRA UTILIZAR ESTE COMANDO, DESCULPE, QUEM SABE UM DIA ğŸ˜‚')  
if(q.length < 1) return reply('Quer adicionar uma alma?')  
try {
tdt = args[0]
if(tdt.length < 1) return reply(`Digita o nÃºmero que deseja add, exemplo: ${prefix}add 558198923680`)
if (info.message.extendedTextMessage === null || info.message.extendedTextMessage === undefined) {
adduser = q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`
if(groupMetadata.participants.includes(adduser)) return reply('Esse membro jÃ¡ estÃ¡ no grupo, como vocÃª vai adicionar??? ')
reply('Irei adicionar ele(a) em 5 segundos...')  
setTimeout(async() => {
responser = await conn.groupParticipantsUpdate(from, [adduser], "add")
}, 5000)
o = responser.participants[0]
let inv = (Object.values(o))
if(inv[0].code == 409) return reply('O alvo jÃ¡ estÃ¡ no grupo!')
if(inv[0].code == 403) return reply('Erro, conta privada do usuÃ¡rio')
if(inv[0].code == 408) return reply('Erro, usuÃ¡rio acabou de sair')
if(inv[0].code == 401) return reply('Erro, porque o bot estÃ¡ bloqueado pelo alvo ')
} else {
if(groupMetadata.participants.includes(adduser)) return reply('Esse membro jÃ¡ estÃ¡ no grupo, como vocÃª vai adicionar??? ')  
reply('Irei adicionar ele(a) em 5 segundos...')  
adduser = info.message.extendedTextMessage.contextInfo.participant
setTimeout(async() => {
responser =  await conn.groupParticipantsUpdate(from, [adduser], "add")
}, 5000)
o = responser.participants[0]
let inv = (Object.values(o))
if(inv[0].code == 409) return reply('O alvo jÃ¡ estÃ¡ no grupo! ')
if(inv[0].code == 403) return reply('Falhou, porque em privado ')
if(inv[0].code == 408) return reply('Falha, porque o alvo acabou de sair ')
if(inv[0].code == 401) return reply('Falha, porque o bot estÃ¡ bloqueado pelo alvo ')
}
} catch {
reply('Izi, se nÃ£o for adicionado provavelmente ele privou sÃ³ para contatos adicionar ele em grupo.')
}
break

case 'ban':
if (!isGroup) return reply('Este comando sÃ³ deve ser utilizado em Grupo.')
if (!isGroupAdmins) return reply('VocÃª precisa ser ADM pra utilizar este comando')
if (!isBotGroupAdmins) return reply('Bot precisa ser ADM, para executar esta funÃ§Ã£o.')
if (info.message.extendedTextMessage != undefined || info.message.extendedTextMessage != null) {
num = info.message.extendedTextMessage.contextInfo.participant
if(botNumber.includes(num)) return reply('NÃ£o sou beste de remover eu mesmo nÃ© ğŸ™, mas estou decepcionado com vocÃª')
if(numerodono.includes(num)) return reply('NÃ£o posso remover meu dono ğŸ¤§')
conn.sendMessage(from, {text: `Adeus ${num.split('@')[0]}`, mentions: [num]}, {quoted: info})
conn.groupParticipantsUpdate(from, [num], 'remove')
} else { 
reply('Responda a mensagem da pessoa')
}
break


//======â‰ (INFOS/EXECUÃ‡ÃƒO/DONO)â‰ =========\\

case 'apresentar':
case 'apr':  
inff = `Bem vindo(a) ao grupo : ${groupName}


ğŸ‘¾ â€¢ğ‘¬ğ‘µğ‘»ğ‘¹ğ‘¶ğ‘¼ ğ‘ºğ‘¬ ğ‘¨ğ‘·ğ‘¹ğ‘¬ğ‘ºğ‘¬ğ‘µğ‘»ğ‘¨â€¢
ğŸ“¸ â€¢Fğœ£Tğœ£
ğŸ‘» â€¢Nğœ£ME
ğŸ“Œ â€¢CIDâˆ†DE
ğŸ—“ï¸ â€¢IDâˆ†DE
âš ï¸ â€¢LEIâˆ† âˆ†S REGRâˆ†S Dğœ£ GRUPğœ£

*APROVEITE O GRUPO!*`
conn.sendMessage(from, {text: inff}, {quoted: selo})
break

case 'papof':
case 'regraspp':  
if(!isGroupAdmins) return reply('Qual foi membro comum?')
txtz = `ã€á¯½ğ’‹¨ğŸ“·:ğ‘†ğ‘’ ğ‘ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘–ğ‘¥ğ‘œğ‘ ğŸŒšÂ»Â°ã€‘
ğ’‹¨Î‡à£­à£ªÌ‡ğŸ”¥É´á´á´á´‡:
ğ’‹¨Î‡à£­à£ªÌ‡ğŸ”¥Éªá´…á´€á´…á´‡:
ğ’‹¨Î‡à£­à£ªÌ‡ğŸ”¥Ê€á´€Ê™á´€:
*Aá´˜Ê€á´‡sá´‡É´á´›á´‡-sá´‡ sá´‡ Ç«á´œÉªsá´‡Ê€.*
ğ™ğ˜¼ğ™‚ğ™â­×‚áœ”à ­ â¸â‚ˆâ¸|ğŸ–ğŸ–ğŸ–|ğŸ ğŸ ğŸ | à½ºà½²â¸â¸â¸
 â”€â”€â•Œâ•Œâ•Œâ”ˆâŠ°â˜…âŠ±â”ˆâ•Œâ•Œâ•Œâ”ˆâ”€
âŒ ENTROU NO 
GRUPO INTERAJA, NÃƒO PRECISAMOS DE ENFEITES,INATIVOS SERAO REMOVIDOS âŒ* 

/ï¹‹<,ï¸»â•¦â•¤â”€ Ò‰ - -----ğŸ’¥ 
/ï¹‹ ğŸ…´ ğŸ…±ğŸ…´ğŸ…¼ ğŸ†…ğŸ…¸ğŸ…½ğŸ…³ğŸ…¾ ğŸ†‚ğŸ…´ğŸ†„ğŸ†‚ ğŸ…µğŸ…¸ğŸ…»ğŸ…·ğŸ…¾ğŸ†‚ ğŸ…³ğŸ…° ğŸ…¿ğŸ†„ğŸ†ƒğŸ…°`
conn.sendMessage(from, {text: txtz}, {quoted: selo})
break

case 'digt':
bla = `ğŸ”¥â†¯ğ‰ğ€ ğ„ğğ“ğ‘ğ€ ğƒğˆğ†ğˆğ“ğ€ğğƒğ ğš½ğˆ â†¯Â°ğŸŒšğŸ’•
           à½²â‹® à¾€ğŸŒ´â à½²â‹® à¾€ğŸš¸ à½²â‹® à¾€âğŸŒ´ à½²â‹® à¾€ 

ğŸ¼ğŸ§â†¯ğ– ğ–°ğ–´ğ–¨ ğ–µğ–®ğ–¢ğ–¤Ì‚ ğ–¯ğ–®ğ–£ğ–¤ ğ–²ğ–¤ğ–±â†¯ğŸ§ğŸ»
ã…¤ã…¤ã…¤ã…¤  â—Û«â€âƒ˜à£­à£­à£­à£­Ùœê”·âƒ”à»‘à£­à£­ÙœâŸ…â—ŒÙœğŸ›¸â—ŒâŸ†à£­à£­Ùœà»‘âƒ•ê”·âƒ˜à£­à£­à£­à£­Ùœâ€Û«â—à£­à£­à£­à£­à½² à½´
    ã€âœ”ã€‘á´˜Ê€á´‡á´›á´€ğŸ‘©ğŸ¾â€ğŸ¦± ã€âœ”ã€‘Ê™Ê€á´€É´á´„á´€ğŸ‘©ğŸ¼
    ã€âœ”ã€‘á´á´€É¢Ê€á´€ğŸ§ã€âœ”ã€‘É¢á´Ê€á´…á´€ğŸ¿
    ã€âœ”ã€‘á´˜á´Ê™Ê€á´‡ğŸª™ ã€âœ”ã€‘Ê€Éªá´„á´€ğŸ’³
    ã€âœ”ã€‘Ê™á´€Éªá´€É´á´€ğŸ’Œã€âœ”ã€‘á´á´€á´„á´É´Êœá´‡ÉªÊ€á´€ğŸ
    ã€âœ”ã€‘á´á´›á´€á´‹á´œğŸ§§ã€âœ”ã€‘á´‡-É¢ÉªÊ€ÊŸğŸ¦„
    ã€âœ”ã€‘ÊŸá´ÊŸÉªğŸ­    ã€âœ”ã€‘É¢á´€á´…á´ğŸƒ
    ã€âœ”ã€‘É¢á´€ÊğŸ³ï¸â€ğŸŒˆ     ã€âœ”ã€‘ÊŸá´‡sÊ™Éªá´„á´€âœ‚ï¸
    ã€âœ”ã€‘á´ á´€á´…Éªá´€ğŸ’„  ã€âœ”ã€‘á´›Ê€á´€á´ á´‡á´„á´ğŸŒ
                ã€âœ”ã€‘É´ÉªÉ´É¢á´œá´‡á´ ÊŸÉªÉ¢á´€ğŸ“µ
. â˜ªï¸ â€¢ â˜ï¸. . â€¢.
ã€ ğ•ğ„ğŒ ğ†ğ€ğ‹ğ„ğ‘ğ€, ğ’ğ„ ğƒğˆğ•ğ„ğ‘ğ“ğˆğ‘ ğ„ ğ…ğ€ğ™ğ„ğ‘ ğğ€ğ‘ğ“ğ„ ğƒğ€ ğ…ğ€ğŒğˆğ‹ğˆğ€.ã€‘ğŸ¥‚`
conn.sendMessage(from, {text: bla}, {quoted: selo})
break

case 'autoban':
if (!isGroup) return reply(enviar.msg.adm)
if (!isGroupAdmins && !SoDono) return reply('Precisa ser Dono')
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
var ind = dbids.indexOf(from)
if(isAdeusCara) {
adeuscara[ind].actived = true
} else {
adeuscara.push({
groupId: from,
actived: true,
number: []
})
}
fs.writeFileSync('./datab/grupos/adeuscara.json', JSON.stringify(adeuscara, null, 2) + '\n')
reply(`Ativou com sucesso o recurso de autoban neste grupoâœ”ï¸`)
} else if (Number(args[0]) === 0) {
var ind = dbids.indexOf(from)						
if(isAdeusCara) {
adeuscara[ind].actived = false
} else {
adeuscara.push({
groupId: from,
actived: false,
number: []
})
}
fs.writeFileSync('./datab/grupos/adeuscara.json', JSON.stringify(adeuscara, null, 2) + '\n')
reply(`Desativou com sucesso o recurso de autoban neste grupoâœ”ï¸`)
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'listban':
if (!isGroup) return reply(enviar.msg.adm)
if (!isGroupAdmins) return reply(enviar.msg.adm)
var ind = dbids.indexOf(from)
if(!isAdeusCara) return reply('*Nenhum NÃºmero nÃ£o foi adicionado*')
teks = '*NÃºmeros que vou moer na porrada se voltar ğŸ˜¡:*\n'
for(i=0;i<adeuscara[ind].number.length;++i) {
teks += `â¤ *${adeuscara[ind].number[i]}*\n`
}
teks += '*Esses ai vou descer meu martelo do ban ğŸ¥µ*'
reply(teks)
break  

case 'listagp': //case by: Bielzinho-Bot
if (!SoDono && !isnit && !info.key.fromMe) return reply('```SOMENTE MEU DONO LINDÃƒO```')
tdufg = await store.chats.all()
ingfoo = await getGroup(tdufg)
teks1 = `*L I S T A  D E  G R U P O S*\n*Total de Grupos* : ${ingfoo.length}\n\n`
for (let i = 0; i < ingfoo.length; i++){
teks1 += `â€¢ *Nome do Grupo* : ${ingfoo[i].subject}\nâ€¢ *Id do Grupo* : ${ingfoo[i].id}\nâ€¢ *Criado* : ${moment(`${ingfoo[i].creation}` * 1000).tz('America/Sao_Paulo').format('DD/MM/YYYY HH:mm:ss')}\nâ€¢ *Total de Membros* : ${ingfoo[i].participants.length}\n\n`
}
reply(teks1)
break

case 'addautorm':
case 'addautoban':
case 'listanegra':  
if (!isGroup) return reply(enviar.msg.adm)
if (!isGroupAdmins && !SoDono) return reply('Precisa ser Dono')
if (args.length < 1) return reply('Cade o nÃºmero?')
var ind = dbids.indexOf(from)
if(isAdeusCara) {
listng = q.replace(new RegExp("[()+-/ +/]", "gi"), "")  
var numind = adeuscara[ind].number.indexOf(listng)
if(numind >= 0) return reply('*Esse NÃºmero ja esta incluso*')
adeuscara[ind].number.push(listng)
} else {
listng = q.replace(new RegExp("[()+-/ +/]", "gi"), "")    
adeuscara.push({
groupId: from,
actived: false,
number: [listng]
})
}
fs.writeFileSync('./datab/grupos/adeuscara.json', JSON.stringify(adeuscara, null, 2) + '\n')
reply(`*NÃºmero adicionado a lista de autoban*`)
break

case 'delremover':
case 'delautorm':  
case 'delautoban': 
case 'tirardalista':  
if (!isGroup) return reply(enviar.msg.adm)
if (!isGroupAdmins && !SoDono) return reply('Precisa ser Dono')
if (args.length < 1) return reply('Diga o numero sem espaÃ§o, + ou traÃ§o')
if (isNaN(args[0])) return reply('Diga o numero sem espaÃ§o, + ou traÃ§o')
var ind = dbids.indexOf(from)
if(!isAdeusCara) return reply('*Nenhum NÃºmero nÃ£o foi adicionado*')
var numind = adeuscara[ind].number.indexOf(args[0])
if(numind < 0) return reply('*Esse nÃºmero nÃ£o estÃ¡ incluso*')
adeuscara[ind].number.splice(numind, 1)
fs.writeFileSync('./datab/grupos/adeuscara.json', JSON.stringify(adeuscara, null, 2) + '\n')
reply(`*NÃºmero removido a lista de autoban*`)
break

case 'banghost':
case 'banghosts':  
if(!SoDono && !isnit) return reply("COMANDO DESATIVADO POR QUESTÃ•ES DE SEGURANÃ‡A, PODE CAUSAR BANIMENTO NO NÃšMERO DO BOT.")
if(!isGroup) return reply(enviar.msg.grupo)
if(groupIdscount.indexOf(from) >= 0) {
for(let obj of groupMembers) {
if(numbersIds.indexOf(obj.id) >=0) { 
var indnum = numbersIds.indexOf(obj.id)
if(countMessage[ind].numbers[indnum].messages <= args[0]) {
if(groupAdmins.includes(obj.id)) {
mentions(`@${obj.id} ta liberado da inspeÃ§Ã£o por ser admin`, [obj.id], true)
} else {
conn.groupParticipantsUpdate(from, [obj.id], 'remove')
}
}
} else {
if(groupAdmins.includes(obj.id)) {
mentions(`@${obj.id} ta liberado da inspeÃ§Ã£o por ser admin`, [obj.id], true)
} else {
conn.groupParticipantsUpdate(from, [obj.id], 'remove')
}
}
}
}
break

case 'correio':
txt = body.slice(10)
txtt = args.join(" ")
txt1 = txt.split("/")[0];
txt2 = txtt.split("/")[1];
if(!txt) return reply('Cade o nÃºmero da pessoa?')
if(!txtt) return reply('Cade a mensagem do correio??')
if(txt.includes("-")) return reply('Tem que ser o nÃºmero junto sem +, e nÃ£o pode tÃ¡ separado da /')
if(txtt.includes("+")) return reply('Tem que ser o nÃºmero junto sem +, e nÃ£o pode tÃ¡ separado da /')
if(!txtt.includes("/")) return reply(`Exemplo: ${prefix}correio 558198923680/Oi Amor, sdds`)
bla = 
`â•­â”„â”â”„â”â”„â”â”„â”â”„â”â•®
â”â”§Â â¸™. ÍÛ«ÛªÂ Â Â Â Â Â Â Â Â Â ğŸ’ŒÂ Â ËÍ¡â‚Šê‹êŒê‹êŒ
â”â”§Correio anÃ´nimo. 
â”â”§Msg: ${txt2}
â”â”§
â•°â”„â”â”„â”â”„â”â”„â”â”„â”â•®`
conn.sendMessage(`${txt1}@s.whatsapp.net`, {text: bla})
break

case 'nome-bot':
if (!SoDono  && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)  
setting.NickDono = args.join(" ") 
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, '\t'))
reply(`O nome do seu bot foi alterado com sucesso para : ${setting.NomeDoBot}`)
break

case 'nick-dono':
if (!SoDono  && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)  
setting.NickDono = args.join(" ")
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, '\t'))
reply(`O Nick Do Dono foi configurado para : ${setting.NickDono}`)
break

case 'numero-dono':
if (!SoDono && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)  
setting.numerodono = args[0]
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, '\t'))
reply(`O nÃºmero dono foi configurado com sucesso para : ${setting.numerodono}`)
break

case 'prefixo-bot':
if (args.length < 1) return
if (!SoDono  && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)
setting.prefix = args[0]
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, '\t'))
reply(`O prefixo foi alterado com sucesso para: ${setting.prefix}`)
break

case 'setprefix':
if (args.length < 1) return
if (!SoDono  && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)
setting.prefix = args[0]
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, '\t'))
reply(`O prefixo foi alterado com sucesso para: ${setting.prefix}`)
break

case 'fotomenu':
case 'fundomenu':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if(!isQuotedImage) return reply("Marque uma imagem")
reply('VocÃª deve marcar uma imagem 2 vez com esse comando..')
if ((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && args.length == 0) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
imagem = await downloadContentFromMessage(boij, 'image')
owgi = Buffer.from([])
for await(const send of imagem) { owgi = Buffer.concat( [ owgi, send ] ) }
res = await upload(owgi)
logoslink.logo = logo
logo = res
fs.writeFileSync('./logos/logos.json', JSON.stringify(logoslink, null, '\t'))
reply(`A foto do menu foi alterada com sucesso para: ${logo}`)
} else {
reply(`Mande uma imagem/vÃ­deo com a legenda ${prefix + command}`)
}
break

case 'setprefixs':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
prefix = args[0]
setting.prefix = prefix
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, '\t'))
reply(`O prefixo foi alterado com sucesso para: ${prefix}`)
break

case 'nomegp':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
await conn.groupUpdateSubject(from, `${body.slice(9)}`)
await conn.sendMessage(from, {text: 'Sucesso, alterou o nome do grupo'}, {quoted: info})
break

case 'fotobot':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (!isQuotedImage) return reply(`Envie fotos com legendas ${prefix}fotobot ou tags de imagem que jÃ¡ foram enviadas`)
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
await conn.updateProfilePicture(botNumber, buff)
reply('Obrigado pelo novo perfilğŸ˜—')
break

case 'clonar':
if (!SoDono  && !isnit && !issupre && !ischyt) return reply('VocÃª quem Ã© o proprietÃ¡rio?')
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply('Marque a pessoa que vocÃª quer clonar\n\n*EXEMPLO:* clone @')
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Tag cvk')
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid[0]
let { jid, id, notify } = groupMembers.find(x => x.id === mentioned)
try {
pp = await conn.profilePictureUrl(id)
buffer = await getBuffer(pp)
conn.updateProfilePicture(botNumber, buffer)
mentions(`Foto do perfil atualizada com sucesso, usando a foto do perfil @${id.split('@')[0]}`, [id], true)
} catch (e) {
reply('Putz, deu erro, a pessoa deve estar sem foto ğŸ˜”')
}
break

case 'leveling':
if (!isGroup) return reply('SÃ³ em Grupo')
if (!isGroupAdmins) return reply('VocÃª precisa ser adm')
if (args.length < 1) return reply('Ative pressione 1, Desativar pressione 0')
if (Number(args[0]) === 1) {
if (isLevelingOn) return reply('*O recurso de nÃ­vel jÃ¡ estava ativo antes*')
_leveling.push(from)
fs.writeFileSync('./datab/usuarios/leveling.json', JSON.stringify(_leveling))
reply(enviar.levelon) 
} else if (Number(args[0]) === 0) {
if (!isLevelingOn) return reply(`O recurso de level jÃ¡ estÃ¡ Desativado neste grupo.`)
_leveling.splice(from, 1)
fs.writeFileSync('./datab/usuarios/leveling.json', JSON.stringify(_leveling))
reply(enviar.leveloff)
} else {
reply('ã€Œ* Adicionar parÃ¢metro 1 ou 0 ')
}
break

case 'ganharlevel':
if(!SoDono) return reply("VocÃª nÃ£o Ã© dono para utilizar este comando...")
addLevelingLevel(sender, 10)
reply("OlÃ¡ chefe, foi adicionado 10 Level para vocÃª ğŸ™‚")
break

case 'ganharxp':
if(!SoDono) return reply("VocÃª nÃ£o Ã© dono para utilizar este comando...")  
addLevelingXp(sender, 5000)
reply("Foi adicionado 5000 mil de XP para vocÃª ğŸ™‚")
break

case 'level':
if (!isLevelingOn) return reply(`*O recurso de level estÃ¡ Desativado, para ativar consulte algum adm e mande ele digitar : ${prefix}leveling 1`)
if (!isGroup) return reply(enviar.msg.grupo)
const userLevel = getLevelingLevel(sender)
const userXp = getLevelingXp(sender)
if (userLevel === undefined && userXp === undefined) return reply(enviar.levelnol)
sem = sender.replace('@s.whatsapp.net','')
                resul = `     
            â—ª *REGISTRO* â—ª                                                                  
            
  â”œâ”€ â *NICK* : ${pushname}
  â”œâ”€ â *NÃšMERO* : ${sender.split("@")[0]}
  â”œâ”€ â *PATENTE* : ${patt}               
  â”œâ”€ â *XP* : ${userXp}
  â””â”€ â *LEVEL* : ${userLevel}`
await conn.sendMessage(from, {text: resul}, {quoted: info})
.catch(async (err) => {
console.error(err)
await reply(`Error!\n${err}`)
})
break

case 'bcgp':
case 'bcgc':  
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply('.......')
fgp = await groupMembers
var nomor = info.participant
if (isMedia && !info.message.videoMessage || isQuotedImage) {
encmedia = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
for (let _ of fgp) {
conn.sendMessage(_.id, {image: buff}, {caption: `*ã€Œ TRANSMISSÃƒO ã€*\n\nGrupo: ${groupName}\n NÃºmero: wa.me/${(sender.split('@')[0])}\nMensagem : ${body.slice(6)}`})
}
reply('')
} else {
for (let _ of fgp) {
sendMess(_.id, `*ã€Œ TRANSMISSÃƒO ã€*\n\nGrupo : ${groupName}\n NÃºmero : wa.me/${(sender.split('@')[0])}\nMensagem : ${body.slice(6)}`)
}
reply('Grupo de transmissÃ£o bem-sucedido')
} 
break

case 'dono1':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
dono1 = body.slice(8)
nescessario.dono1 = dono1
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um segundo dono(a) alterado com sucesso para: ${dono1}`)
break

case 'dono2':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
dono2 = body.slice(8)
nescessario.dono2 = dono2
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um segundo dono(a) alterado com sucesso para: ${dono2}`)
break

case 'dono3':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
dono3 = body.slice(8)
nescessario.dono3 = dono3
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um terceiro dono(a) alterado com sucesso para: ${dono3}`)
break

case 'dono4':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
dono4 = body.slice(8)
nescessario.dono4 = dono4
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um quarto dono(a) alterado com sucesso para: ${dono4}`)
break

case 'dono5':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
dono5 = body.slice(8)
nescessario.dono5 = dono5
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um quinto dono(a) alterado com sucesso para: ${dono5}`)
break

case 'dono6':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
dono6 = body.slice(8)
nescessario.dono6 = dono6
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um quinto dono(a) alterado com sucesso para: ${dono6}`)
break

case 'getquoted':
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo, null, 3))
break

case 'donos':
p = `[ Lista de donos do bot ${setting.NomeDoBot} ] 

Dono Oficial do bot: ${setting.numerodono}

- [ 1 ] ${nescessario.dono1}\n- [ 2 ] ${nescessario.dono2}\n- [ 3 ] ${nescessario.dono3}\n- [ 4 ] ${nescessario.dono4}\n- [ 5 ] ${nescessario.dono5}\n- [ 6 ] ${nescessario.dono6} `
reply(p)
break

case 'online':   
case 'onlines':  //case by: á¬ŠÍ¡Íœğ‘©ğ‘°ğ‘¬ğ‘³ğ’ğ‘°ğ‘µğ‘¯ğ‘¶.ğ‘¬ğ‘¿ğ‘¬áµ’á¶ á¶œ
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono && !isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
let ido = args && /\d+\-\d+@g.us/.test(args[0]) ? args[0] : from
let online = [...Object.keys(store.presences[ido]), conn.user.id]
conn.sendMessage(from, {text: 'Pessoas online do gp:\n\n' + online.map(v => 'â€¢ @' + v.replace(/@.+/, '')).join`\n`}, {quoted: info})
break

case 'admins':
case 'listadmins':  
case 'listaadmins':   
if (!isGroup) return reply(enviar.msg.grupo)
ytb = `Lista de admins do grupo *${groupMetadata.subject}*\nTotal : ${groupAdmins.length}\n\n`
no = 0
for (let admon of groupAdmins) {
no += 1
ytb += `[${no.toString()}] @${admon.split('@')[0]}\n`
}
mentions(ytb, groupAdmins, true)
break

case 'criartabela': case 'criartbl': case 'criartab':
if(!isGroupAdmins || !SoDono) return 
msgz = args.join(" ")

msgtmpol = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

datinhaofc = moment.tz('America/Sao_Paulo').format('DD/MM/YY');

var blarpty = {
Horario: msgtmpol, 
Data: datinhaofc, 
Tabela: msgz
}

if(!fs.existsSync(`./func/tabela/tabela-${from}.json`)) {
fs.writeFileSync(`./func/tabela/tabela-${from}.json`,
JSON.stringify(blarpty, null, 2));
} else {
if (fs.existsSync("./func/tabela/tabela-" + from + ".json")) {
fs.unlinkSync("./func/tabela/tabela-" + from + ".json");
fs.writeFileSync(`./func/tabela/tabela-${from}.json`,
JSON.stringify(blarpty, null, 2));
}
}
reply(`Tabela do grupo foi criada com sucesso..`)
break

case 'tabelagp': case 'tabeladogp': case 'tabelinha': 
if(!fs.existsSync(`./func/tabela/tabela-${from}.json`)) {
reply(`Cade a tabela, cria ela com o comando\nExemplo : ${prefix}criartabela lindas do grupo : e etc ..`)
}
const tabelagpofc = JSON.parse(fs.readFileSync(`./func/tabela/tabela-${from}.json`)); 

blity = `- â° HorÃ¡rio que criou a Tabela : ${tabelagpofc.Horario}\n\n- ğŸ—“ï¸ Data que criou a Tabela : ${tabelagpofc.Data}\n\n - Tabela : ${tabelagpofc.Tabela}`

conn.sendMessage(from, {text: blity}, {quoted: info})
break

case 'ausente': case 'off': case 'afk':
if(!SoDono) return reply("Comando especial para o dono.")
msgtmp = moment.tz('America/Sao_Paulo').format('HH:mm:ss');
nmrdnofc = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "")
msgz = args.join(" ")

var catmsgaus = {
Ausente_Desde: msgtmp, 
Motivo_Da_AusÃªncia: msgz
}

if(!fs.existsSync(`./func/afk/afk-@${nmrdnofc}.json`)) {
fs.writeFileSync(`./func/afk/afk-@${nmrdnofc}.json`,
JSON.stringify(catmsgaus, null, 2));
} else {
if (fs.existsSync("./func/afk/afk-@" + nmrdnofc + ".json")) {
fs.unlinkSync("./func/afk/afk-@" + nmrdnofc + ".json");
fs.writeFileSync(`./func/afk/afk-@${nmrdnofc}.json`,
JSON.stringify(catmsgaus, null, 2));
}
}
reply(`Mensagem de ausÃªncia criada com sucesso...`)
break

case 'ativo': case 'on': case 'voltei':
if(!SoDono) return reply("Comando especial para o dono.")
nmrdnofc = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "")
if (fs.existsSync("./func/afk/afk-@" + nmrdnofc + ".json")) {  
fs.unlinkSync("./func/afk/afk-@" + nmrdnofc + ".json");
reply("Bem vindo de volta, agora vocÃª estÃ¡ online ğŸ™‚")
} else {
reply("VocÃª nÃ£o registrou nenhuma mensagem de ausÃªncia...")
}
break

case 'serpremium':
case 'serprem':  
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
premium.push(`${setting.numerodono}@s.whatsapp.net`)
fs.writeFileSync('./datab/usuarios/premium.json', JSON.stringify(premium))
reply(`Pronto ${setting.numerodono} vocÃª foi adicionado na lista premium.`)
break

case 'addpremium':
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return 
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
premium.push(`${mentioned}`)
fs.writeFileSync('./datab/usuarios/premium.json', JSON.stringify(premium))
susp = `ğŸ‘‘@${mentioned[0].split('@')[0]} foi adicionado Ã  lista de usuÃ¡rios premium com sucessoğŸ‘‘`
mentions(`${susp}`, mentioned, true)   
break 

case 'delpremium':
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return  reply(enviar.msg.donosmt)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return 
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
let position = false
Object.keys(premium).forEach((i) => {
if (premium[i] === mentioned) {
position = i
}
})
if (position !== false) {
premium.splice(position, 1)
fs.writeFileSync('./datab/usuarios/premium.json', JSON.stringify(premium))
}
susp = `âœ–@${mentioned[0].split('@')[0]} foi removido da lista de usuÃ¡rios premiumâœ–`
mentions(`${susp}`, mentioned, true)   
break 

case 'limpar':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
clear = `ğŸ—‘ï¸\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nğŸ—‘ï¸\nâ²â—â³ *LÉªá´á´˜á´‡á´¢á´€ á´…á´‡ CÊœá´€á´› Cá´É´á´„ÊŸá´œÉªÌá´…á´€* âœ…`
if(verificado === true) {
conn.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
} else {
conn.sendMessage(from, {text: clear}, {quoted: info, contextInfo : { forwardingScore: 500, isForwarded:true}})  
}
break
case 'clearchat':
case 'limparchat':  
case 'limparmsg':  
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
await conn.chatModify({ clear: { message: { id: String, fromMe: true } } }, from, [])
reply("Chat limpo")
break

case 'addpalavra':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (args.length < 1) return reply( `Use assim : ${prefix + command} [palavrÃ£o]. exemplo ${prefix + command} puta`)
const bw = body.slice(12)
palavra.push(bw)
fs.writeFileSync('./datab/grupos/palavras.json', JSON.stringify(palavra))
reply('PalavrÃ£o adicionado com sucesso!')
await limitAdd(sender)
break

case 'delpalavra':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (args.length < 1) return reply( `Use assim : ${prefix + command} [palavrÃ£o]. exemplo ${prefix + command} puta`)
let dbw = body.slice(12)
palavra.splice(dbw)
fs.writeFileSync('./datab/grupos/palavras.json', JSON.stringify(palavra))
reply('PalavrÃ£o removido da lista com sucesso!')
await limitAdd(sender)
break

case 'listapalavrÃ£o': case 'listapalavra':
case 'listpalavra':
let lbw = `Esta Ã© a lista de palavrÃ£o\nTotal : ${palavra.length}\n`
for (let i of palavra) {
lbw += `â¸ ${i.replace(palavra)}\n`
}
await reply(lbw)
await limitAdd(sender)
break 

case 'legendabv':  
if(!isGroup) return reply('Este comando sÃ³ deve ser utilizado em Grupo.')
if(!isGroupAdmins) return reply(`SÃ³ ADM pode utilizar este comando.`)
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = body.slice(11)
if(isWelcomed) {
var ind = groupIdWelcomed.indexOf(from)
welcome_group[ind].msg = teks
fs.writeFileSync('./datab/grupos/welcomegp.json', JSON.stringify(welcome_group, null, 2) + '\n')
reply('*Mensagem de boas vindas alteradas com sucesso!*')
} else {
var json = {
id: from,
msg: teks
}
welcome_group.push(json)
fs.writeFileSync('./datab/grupos/welcomegp.json', JSON.stringify(welcome_group, null, 2) + '\n')
reply('*Mensagem de boas vindas criada com sucesso!*')
}
break

case 'legendasaiu':
if(!isGroup) return reply(`SÃ³ em grupo pode utilizar este comando.`)
if(!isGroupAdmins) return reply(`SÃ³ ADM pode utilizar este tipo de Comando.`)
if(args.length < 1) return reply('*Escreva a mensagem de saÃ­da*')
teks = body.slice(13)
if(isByed) {
var ind = groupIdBye.indexOf(from)
bye_group[ind].msg = teks
fs.writeFileSync('./datab/grupos/byegp.json', JSON.stringify(bye_group, null, 2) + '\n')
reply('*Mensagem de saÃ­da alteradas com sucesso!*')
} else {
var json = {
id: from,
msg: teks
}
bye_group.push(json)
fs.writeFileSync('./datab/grupos/byegp.json', JSON.stringify(bye_group, null, 2) + '\n')
reply('*Mensagem de saÃ­da criada com sucesso!*')
}
break

case 'legendabv2':  
if(!isGroup) return reply('Este comando sÃ³ deve ser utilizado em Grupo.')
if(!isGroupAdmins) return reply(`SÃ³ ADM pode utilizar este comando.`)
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = body.slice(12)
if(isWelcomed2) {
var ind = groupIdWelcomed2.indexOf(from)
welcome_group2[ind].msg = teks
fs.writeFileSync('./datab/grupos/welcomegp2.json', JSON.stringify(welcome_group2, null, 2) + '\n')
reply('*Mensagem de boas vindas2 alteradas com sucesso!*')
} else {
var json = {
id: from,
msg: teks
}
welcome_group2.push(json)
fs.writeFileSync('./datab/grupos/welcomegp2.json', JSON.stringify(welcome_group2, null, 2) + '\n')
reply('*Mensagem de boas vindas2 criada com sucesso!*')
}
break

case 'legendasaiu2':
if(!isGroup) return reply(`SÃ³ em grupo pode utilizar este comando.`)
if(!isGroupAdmins) return reply(`SÃ³ ADM pode utilizar este tipo de Comando.`)
if(args.length < 1) return reply('*Escreva a mensagem de saÃ­da*')
teks = body.slice(14)
if(isByed) {
var ind = groupIdBye.indexOf(from)
bye_group2[ind].msg = teks
fs.writeFileSync('./datab/grupos/byegp2.json', JSON.stringify(bye_group2, null, 2) + '\n')
reply('*Mensagem de saÃ­da2 alteradas com sucesso!*')
} else {
var json = {
id: from,
msg: teks
}
bye_group2.push(json)
fs.writeFileSync('./datab/grupos/byegp2.json', JSON.stringify(bye_group2, null, 2) + '\n')
reply('*Mensagem de saÃ­da2 criada com sucesso!*')
}
break

case 'deletar':  case 'apagar':  case 'delete':   case 'del':  case 'd':
if (!isGroup)return reply(enviar.msg.grupo)
if (!SoDono && !isGroupAdmins && !isPremium) return reply(enviar.msg.adm)
conn.sendMessage(from, { delete: { remoteJid: from, fromMe: true, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: sender }})
.catch((err) => { 
console.log(err)
reply('A mensagem nÃ£o foi enviado pelo bot...')
})
break

case 'fundobemvindo':
case 'fundobv':  
if (!SoDono  && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)
if(!isQuotedImage) return reply("Marque uma imagem")
reply('VocÃª deve marcar uma imagem com esse comando, se nÃ£o for de primeira, tente novamente, ok? ')
if ((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && args.length == 0) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
fundo1 = res
nescessario.fundo1 = fundo1
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`A imagem de bem vindo foi alterado com sucesso para: ${fundo1}`)
}
break

case 'fundosaiu':
if (!SoDono  && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)
if(!isQuotedImage) return reply("Marque uma imagem")
reply('VocÃª deve marcar uma imagem com esse comando, se nÃ£o for de primeira, tente novamente, ok? ')
if ((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && args.length == 0) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
fundo2 = res
nescessario.fundo2 = fundo2
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`A imagem de saiu foi alterado com sucesso para: ${fundo2}`)
}
break

case 'antiligar':
case 'antiligacao':  
case 'antiligaÃ§Ã£o':  
try {
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAnticall) return reply('Ja esta ativo')
anticall.push('Ativado')
fs.writeFileSync('./datab/usuarios/anticall.json', JSON.stringify(anticall))
reply('Ativou com sucesso o recurso de antiligaÃ§Ã£o no botâœ”ï¸')
} else if (Number(args[0]) === 0) {
if (!isAnticall) return reply('Ja esta Desativado')  
fs.writeFileSync('./datab/usuarios/anticall.json', JSON.stringify([]))
reply('Desativou com sucesso o recurso de antiligaÃ§Ã£o no botâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
} catch {
reply('Falha ao ativar')
}
break

case 'antipvon':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe ) return await reply('Apenas Meu Dono')
if (banChats) return await reply('jÃ¡ estÃ¡ ativo o modo antipv')
banChats = true
nescessario.banChats = banChats
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
await conn.sendMessage(from, {text: "*Sucesso alterado para modo antipv, pv nÃ£o poderÃ¡ ser utilizado"})
break

case 'antipvoff':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return await reply('Apenas meu dono o owner')
if (!banChats) return await reply('Nao estava ativado ainda')
banChats = false
nescessario.banChats = banChats
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
await conn.sendMessage(from, {text: "*Sucesso modo antipv desligado, pv liberado."})
break

case 'verificadoon':
case 'vron':  
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe ) return await reply('Apenas Meu Dono')
if (verificado === true) return await reply('Ja esta com verificado ativado em tudo.')
verificado = true
nescessario.verificado = verificado
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
await conn.sendMessage(from, {text: "*VERIFICADO ATIVADO EM TODOS MENUS, INCLUINDO ALGUNS COMANDOS.*"})
break

case 'verificadooff':
case 'vroff':  
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return await reply('Apenas meu dono o owner')
if (verificado === false) return await reply('Ja esta com verificado Desativado em tudo.')
verificado = false
nescessario.verificado = verificado
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
await conn.sendMessage(from, {text: "*VERIFICADO DESATIVADO EM TODOS MENUS, INCLUINDO ALGUNS COMANDOS.*"})
break

case 'antipv':
if (!SoDono) return reply(`Apenas dono pode ativar/desativar essa funÃ§Ã£o..`)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntiPv) return reply('Ja esta ativo')
antipv.push('Ativado')
fs.writeFileSync('./datab/usuarios/antipv.json', JSON.stringify(antipv))
reply('ğŸŒ€ Ativou com sucesso o recurso de Anti Privado ğŸ“')
} else if (Number(args[0]) === 0) {
if (!isAntiPv) return reply('Ja esta Desativado')
pesquisar = 'Ativado'
processo = antipv.indexOf(pesquisar)
while(processo >= 0){
antipv.splice(processo, 1)
processo = antipv.indexOf(pesquisar)
}
fs.writeFileSync('./datab/usuarios/antipv.json', JSON.stringify(welkom))
reply('â€¼ï¸ Desativou com sucesso o recurso De ANTIPVâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'block':
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return  reply(enviar.msg.donosmt)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return 
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
ban.push(`${mentioned}`)
fs.writeFileSync('./datab/usuarios/banned.json', JSON.stringify(ban))
susp = `ğŸš«@${mentioned[0].split('@')[0]} foi banido e nÃ£o poderÃ¡ mais usar os comandos do botğŸš«`
mentions(`${susp}`, mentioned, true)   
break

case 'unblock':
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return  reply(enviar.msg.donosmt)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return 
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
ban.splice(`${mentioned}`)
fs.writeFileSync('./datab/usuarios/banned.json', JSON.stringify(ban))
susp = `â@${mentioned[0].split('@')[0]} foi desbanido e poderÃ¡ novamente usar os comandos do botâ`
mentions(`${susp}`, mentioned, true)   
break

case 'blocklist':
jrc = 'ESTA Ã‰ A LISTA DE NÃšMEROS BLOQUEADOS :\n'
for (let benn of ban) {
jrc += `~> @${benn.split('@')[0]}\n`
}
jrc += `Total : ${ban.length}`
conn.sendMessage(from, jrc.trim(), extendedText, {quoted: info, contextInfo: {"mentionedJid": ban}})
break

case 'acess':
if (!SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
teks = body.slice(7)
exec(teks, (err, stdout) => {
if (err) return conn.sendMessage(from, {text: `root@ALEATORY-BOT:~ ${err}`}, {quoted: info})
if (stdout) {
conn.sendMessage(from, {text: stdout})
}
})
break

case 'bangp':
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (isBanchat) return reply(`Este grupo ja estÃ¡ banido`)
bancht.push(from)
fs.writeFileSync('./datab/grupos/banchat.json', JSON.stringify(bancht))
reply(`Grupo banido com sucesso`)
break

case 'unbangp':
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
let cur = bancht.indexOf(from)
bancht.splice(cur, 1)
fs.writeFileSync('./datab/grupos/banchat.json', JSON.stringify(bancht))
reply(`Grupo desbanido...`)
break

case 'limitec':
if(!SoDono  && !isnit && !ischyt) return reply(enviar.msg.donosmt)
if (args.length < 1) return
if (!setTimeout && !info.key.fromMe) return reply(enviar.msg.donosmt)
limitefl = args.join(" ")
limitefll.limitefl = limitefl
fs.writeFileSync('./datab/usuarios/flood.json', JSON.stringify(limitefll, null, '\t'))
reply(`${limitefl} foi adicionado como limite de antiflood `)
break

case 'execut':
if(!SoDono  && !isnit && !issupre && !ischyt) return
try{
return eval(`(async() => { ${args.join(' ')}})()`)
}catch (e) {
reply(`${e}`)
}
break

case 'exec':
if(!SoDono  && !isnit && !issupre && !ischyt) return
try{
paramsQuoted = info.message.extendedTextMessage.contextInfo.quotedMessage.conversation || info.message.extendedTextMessage.contextInfo.quotedMessage.extendedTextMessage.text;	
return eval(`${paramsQuoted}`)
console.log(`[EXEC]~> ${paramsQuoted}`)
}catch(e){
reply(e)
}
break

case 'speed':
case 'ping':
r = (Date.now() / 1000) - info.messageTimestamp
			uptime = process.uptime()
hora1 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

bla = `
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚ 
â”‚ Velocidade Do Bot + InformaÃ§Ãµes 
â”‚ 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 
â”‚ Velocidade : ${String(r.toFixed(3))}
â”‚ 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tempo Ativo : 
â”‚ [ ${kyun(uptime)} ] 
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚ 
â”‚ Data : ${date} 
â”‚ 
â”‚ Plataforma Ativa : Heroku
â”‚ 
â”‚ Grupo : ${groupName} 
â”‚ 
â”‚ Solicitou Comando : ${pushname}
â”‚ 
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ã€” ${hora1} ã€•
`

await conn.sendMessage(from, {text: bla}, {quoted: selo})
break

case 'gtts':
if (args.length < 1) return conn.sendMessage(from,{text: `Cade o texto?, digite algo Exemplo:\n${prefix}gtts PT Oi`}, {quoted: info})
const gtts = require('./armor/gtts')(args[0])
if (args.length < 2) return conn.sendMessage(from, {text: 'Falta colocar o cÃ³digo do idioma!'}, {quoted: info})
dtt = body.slice(8)
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
if(dtt.length > 200) return reply('Para reduzir spam o mÃ¡ximo de letras permitidas sÃ£o 200!')
gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
fs.unlinkSync(ranm)
buffer = fs.readFileSync(rano)
conn.sendMessage(from, {audio: buffer, ptt:true}, {quoted: info})
fs.unlinkSync(rano)
})
})
break

case 'tagme':
members_id = []  
const tagme = `@${sender.split("@")[0]} âœ”ï¸`
members_id.push(sender.split("@s.whatsapp.net"))
await mentions(tagme, members_id, true)
break

case 'blockcmd':
if(!SoDono  && !isnit) return reply(enviar.msg.donosmt)
tp = args.join(" ")
if(tp.includes("blockcmd blockcmd") || (tp.includes("blockcmd  blockcmd"))) return reply(`TÃ¡ louco maluco?, Quer banir o comando de bloquear comando?`)
if(getComandoBlock(from).includes(args[0]))return reply('Este comando jÃ¡ estÃ¡ blockeado')
addComandos(from, args[0])
reply(`O comando ${args[0]} Foi blockeado`)
break

case 'unblockcmd':
if(!SoDono  && !isnit) return reply(enviar.msg.donosmt)
tp = args.join(" ")
if(tp.includes("blockcmd unblockcmd") || (tp.includes("blockcmd  unblockcmd"))) return reply(`TÃ¡ louco maluco?, Quer banir o comando de desbloquear comando?`)  
if(!getComandoBlock(from).includes(args[0]))return reply('Este comando jÃ¡ estÃ¡  desbloqueado')
deleteComandos(from, args[0])
reply(`O comando ${args[0]} Foi desblockeado`)
break

case 'listacomandos':
tkks = 'â•­â”€*ã€Œ *COMANDOS BLOCK* ã€\n'
for (let V of getComandoBlock(from)) {
tkks += `â”‚+  ${V}\n`
}
tkks += `â”‚+ Total : ${getComandoBlock(from).length}\nâ•°â”€â”€â”€â”€â”€â”€*ã€Œ *${NomeDoBot}* ã€*â”€â”€â”€â”€`
await conn.sendMessage(from, tkks.trim(), extendedText, {quoted: info})
break

case 'avalie':
const avalie = body.slice(8)
if (args.length <= 1) return reply(`Exemplo: ${prefix}avalie "Bot muito bom, parabÃ©ns. "`)
if (args.length >= 400) return conn.sendMessage(from, {text: 'MÃ¡ximo 400 caracteres'}, {quoted: info})
var nomor = info.participant
tdptls = `[ AvaliaÃ§Ã£o ]\nDe: wa.me/${sender.split("@s.whatsapp.net")[0]}\n: ${avalie}`
var options = {
text: tdptls,
contextInfo: {
mentionedJid: [sender]
},
}
await conn.sendMessage(`${setting.numerodono}@s.whatsapp.net`, {text: options}, {quoted: info})
reply("mensagem enviada ao meu dono, obrigado pela avaliaÃ§Ã£o, iremos melhorar a cada dia.")
break

case 'bug':
const bug = body.slice(5)
if (args.length <= 1) return reply(`Exemplo: ${prefix}bug "ocorreu um erro no comando sticker"`)
if (args.length >= 800) return conn.sendMessage(from, {text: 'MÃ¡ximo 800 caracteres'}, {quoted: info})
var nomor = info.participant
teks1 = `[ Problema ]\nDe: wa.me/${sender.split("@s.whatsapp.net")[0]}\nErro ou bug: ${bug}`
var options = {
text: teks1,
contextInfo: {
mentionedJid: [sender]
},
}
await conn.sendMessage(`${setting.numerodono}@s.whatsapp.net`, {text: options}, {quoted: info})
reply("mensagem enviada ao meu dono, se enviar muitas mensagens repetida por zoueiras, vocÃª sera banido de utilizar os comandos do bot.")
break

case 'sugestÃ£o':
case 'sugestao':
const sugestao = body.slice(10)
if (args.length <= 1) return reply(`Exemplo: ${prefix}sugestao "Opa, crie um comando tal, que ele funcione de tal maneira, isso serÃ¡ muito bom, nÃ£o sÃ³ pra mim, mas pra vÃ¡rios fazer isso.."`)
if (args.length >= 800) return conn.sendMessage(from, {text: 'MÃ¡ximo 800 caracteres'}, {quoted: info})
var nomor = info.participant
sug = `[ SugestÃµes ]\nDe: wa.me/${sender.split("@s.whatsapp.net")[0]}\n: ${sugestao}`
await conn.sendMessage(`${setting.numerodono}@s.whatsapp.net`, {text: sug}, {quoted: info})
reply("mensagem enviada ao meu dono, obrigado pela sugestÃ£o, tentar ouvir o mÃ¡ximo possÃ­vel de sugestÃµes.")
break

//==========(BAIXAR/PESQUISAS)==========\\

case 'pinterest': 
if(!q) return reply(`Digite o nome da imagem que vc quer buscar\nExemplo: ${prefix + command} cat`)
reply(enviar.espere)
blap = await getBuffer(`http://aleatoryapi.herokuapp.com/api/pinterest?text=${q}&apikey=${keyale}`)
await conn.sendMessage(from, {image: blap, thumbnail: null}, {quoted: info}).catch(e => {
reply('ERROR!!')
})
break

case 'gerarlink':  
case 'imgpralink':    
try {
if (isQuotedImage) {
reply(enviar.espere)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
reply(res)
} else {
reply(`Mande uma imagem com a legenda ${prefix + command}`)
}
} catch {
reply('Ocorreu algum Error, desculpe ğŸ˜”')
}
break

case 'videourl':
case 'videopralink':
try {
if ((isQuotedVideo) && args.length == 0) {
reply(enviar.espere)
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
reply(res)
} else {
reply(`Mande vÃ­deo com a legenda ${prefix + command}`)
}
} catch {
reply('Ocorreu algum Error, desculpe ğŸ˜”/ O limite do tamanho de vÃ­deo que gero o link, Ã© 30 segundos.')
}
break

case 'printsite':
case 'print':
txt = args.join(" ")
if(txt.length < 8) return reply(`Digite qual site vocÃª deseja tirar o print, por Exemplo: ${prefix}printsite Google.com`)
reply(enviar.espere)
printp = await fetchJson(`https://aleatoryapi.herokuapp.com/api/ssweb?url=${txt}&apikey=${keyale}`)
printimg = await getBuffer(printp.link)
conn.sendMessage(from, {image: printimg}, {quoted: info}).catch(e => {
reply('ERROR')
})
break

case 'ytsearch':
try {
psq = args.join(' ')
if(psq.length < 2) return reply(`O que vocÃª deseja encontrar?, diga o nome do vÃ­deo ou da mÃºsica, e irei informar os links que correspondem.`)
blar = await fetchJson(`https://aleatoryapi.herokuapp.com/api/ytsrc?q=${psq}&apikey=${keyale}`)
pla = '==============\n\n'
for (let x of blar.resultado) {
pla += `Titulo: ${x.title}\n`
pla += `Link: ${x.url}`
pla += '\n\n=============\n\n'
}
reply(pla.trim())
} catch {
reply('Error!!')
}
break

case 'igdl':
case 'instadw': 
try {  
link = args.join(' ')
if (!link) return reply('Ops, insira o link de um video/foto do instagram.')
post = await fetchJson(`https://aleatoryapi.herokuapp.com/api/instagram?url=${link}&apikey=${keyale}`)
s_video = await getBuffer(post.resultado[0].downloadUrl)
conn.sendMessage(from, {video: s_video}, {quoted: info})
} catch {
reply('O vÃ­deo deve ser privado, ou Ã© imagem, sÃ³ pode video.')
}
break

case 'twitter':
link = args.join(' ')
if (!link) return reply('Ops, insira o link de um video do twitter')
reply(enviar.espere)
post = await fetchJson(`https://aleatoryapi.herokuapp.com/api/twitter?link=${link}&apikey=${keyale}`)
descc = post.resultado.desc
video_hd = await getBuffer(post.resultado.HD)
conn.sendMessage(from, {video: video_hd, caption: descc}, {quoted: info}).catch(e => {
reply('Error!!')
})
break

case 'facebook':
case 'facemp4':  
case 'fb':
teks = args[0]
reply(enviar.espere)
res = await fbDown(teks).catch(e => {
reply(`${e}`)
})
a = res[0]
result = `ã€Œ *Facebook Downloader* ã€
â€¢ *TÃ­tulo:* ${a.judul}
â€¢ *Fonte :* ${a.source}
â€¢ *Tamanho :* ${a.size}
â€¢ *Qualidade :* ${a.quality}
â€¢ *Modelo :* ${a.type}
â€¢ *Nome do arquivo :* ${a.judul}.${a.type}`
sendFileFromUrl({image: a.thumb, caption: result}, {quoted: info})
sendFileFromUrl({video: a.link, mimetype: 'video/mp4'}, {quoted: info})
await limitAdd(sender)
break

case 'ytmp4':
qd = args.join(" ")
if(qd.length < 7) return reply('VocÃª deve pegar o link do YouTube gerado pelo ytsearch ou do prÃ³prio YouTube mesmo, e usar com esse comando, e ele enviarÃ¡ seu video / mÃºsica de video')
reply(enviar.espere)
res = await fetchJson(`https://aleatoryapi.herokuapp.com/api/ytsrc?q=${qd}&apikey=${keyale}`)

blaimg = await getBuffer(res.resultado[0].image)

bla = `Titulo: ${res.resultado[0].title}\nVisualizaÃ§Ãµes: ${res.resultado[0].views}\nTempo: ${res.resultado[0].duration.timestamp}\nCanal: ${res.resultado[0].author.name}\n`

conn.sendMessage(from, {image: blaimg, caption: bla}, {quoted: info})
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/ytmp4-2?q=${q}&apikey=${keyale}`)
blabla = await getBuffer(bla[0].link)
conn.sendMessage(from, {video: blabla, mimetype: 'video/mp4'}, {quoted: info}).catch(e => {
reply('ERROR')
})
break

case 'ytmp3':
qd = args.join(" ")
if(qd.length < 7) return reply('VocÃª deve pegar o link do YouTube gerado pelo ytsearch ou do prÃ³prio YouTube mesmo, e usar com esse comando, e ele enviarÃ¡ seu Ã¡udio / mÃºsica')
reply(enviar.espere)
res = await fetchJson(`https://aleatoryapi.herokuapp.com/api/ytsrc?q=${qd}&apikey=${keyale}`)

blaimg = await getBuffer(res.resultado[0].image)

bla = `Titulo: ${res.resultado[0].title}\nVisualizaÃ§Ãµes: ${res.resultado[0].views}\nTempo: ${res.resultado[0].duration.timestamp}\nCanal: ${res.resultado[0].author.name}\n`

conn.sendMessage(from, {image: blaimg, caption: bla}, {quoted: info})
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/ytmp3-2?q=${q}&apikey=${keyale}`)
audbla = await getBuffer(bla[0].link)
conn.sendMessage(from, {audio: audbla, mimetype: 'audio/mp4'}, {quoted: info}).catch(e => {
reply('ERROR!!')
})
break
case 'testando1':
bla = await fetchJson(`http://aleatoryapi.herokuapp.com/api/youtubedl?url=https://youtu.be/ffaYsbjmaMs&apikey=key-expr`)
blabla = await getBuffer(bla.medias[0].url) 
conn.sendMessage(from, {audio: blabla, mimetype: 'audio/mp4'}).catch(e => {
reply('ERROR!!')
})
break

case 'tiktok':
link = args.join(" ")
if (!link) return reply('Ops, insira o link de um video do tiktok.')
reply(enviar.espere)
blap = await fetchJson(`http://aleatoryapi.herokuapp.com/api/tiktok?url=${link}&apikey=${keyale}`)
blavideo = await getBuffer(blap.resultado.nowm)
conn.sendMessage(from, {video: blavideo, mimetype: 'video/mp4'}, {quoted: info}).catch(e => {
reply('ERROR!!')
})
break

case 'tiktok2':
qp = args.join(" ")
if (!qp) return reply('Ops, insira o link.')
sendBtext(from, "âœ”ï¸ Download De VÃ­deo / Audio [ TIKTOK ]\nEscolha uma opÃ§Ã£o que deseja.", `â˜‚ï¸`, [
{buttonId: `${prefix}tiktokvideo ${qp}`, buttonText: {displayText: `ğŸ¥ Video`}, type: 1},
{buttonId: `${prefix}tiktokaudio ${qp}`, buttonText: {displayText: `ğŸµ Audio`}, type: 1}], selo)
break 

case 'tiktokvideo': 
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/tiktok-2?url=${q}&apikey=${keyale}`)
blabla = await getBuffer(bla.resultado.server1.video)
conn.sendMessage(from, {video: blabla, mimetype: 'video/mp4'}, {quoted: info}).catch(e => {
reply('ERROR!!')
})
break

case 'tiktokaudio': 
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/tiktok-2?url=${q}&apikey=${keyale}`)
blabla = await getBuffer(bla.resultado.server1.music)
conn.sendMessage(from, {audio: blabla, mimetype: 'audio/mp4'}, {quoted: info}).catch(e => { 
reply('ERROR')
})
break

case 'playstore':
if(!q) return reply('Digite um nome de um app que deseja pesquisar.')
let play = await hx.playstore(q);
let stor = "â‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â‰\n"
for (let i of play) {
stor += `\n*ã€Œ _PLAY STORE_ ã€*\n
- ğŸ“„ *Nome* : ${i.name}
- ğŸŒ€ *Link* : ${i.link}\n
- ğŸ¤µğŸ» *desenvolvedor* : ${i.developer}
- ğŸ“¤ *Desenvolvedor link* : ${i.link_dev}\nâ‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â‰`
}
reply(stor)
break

case 'igstalk':
if(args.length < 1) return reply('CadÃª o nome?')
usur = args.join(" ")
teste = await fetchJson(`https://pencarikode.xyz/stalk/instagram?username=${usur}&apikey=pais`)
teste = teste.result.user
corno = `Nome : ${teste.username}\n`
corno += `PK : ${teste.pk}\n`
testebf = await getBuffer(`${teste.profile_pic_url}`)
await conn.sendMessage(from, {image: testebf, caption: `${corno}`}, {quoted:info})
break

case 'celular':
if (!q) return reply(`Qual celular vocÃª estÃ¡ procurando?`)
teks = args.join(' ')
anu = await fetchJson(`https://api-yogipw.herokuapp.com/api/search/gsmarena?query=${q}`)
const busca_celular = 
`
ğŸ“ Titulo: ${anu.judul}
â—Ãšltima atualizaÃ§Ã£o: ${anu.rilis}
ğŸ“± Tamanho do celular: ${anu.ukuran}
âš¡ Tipo: ${anu.type}
ğŸ—ƒï¸ Armazenamento: ${anu.storage}
ğŸ“´ Tela: ${anu.display}
ğŸ“³ Polegada: ${anu.inchi}
ğŸ”° ResoluÃ§Ã£o da cÃ¢mera: ${anu.pixel}
ğŸ“² ResoluÃ§Ã£o do video: ${anu.videoPixel}
ğŸ’­ Ram do celular: ${anu.ram}
ğŸ‘¤ Hardware do celular: ${anu.chipset}
âš ï¸ Bateria: ${anu.batrai}
ğŸ”‹ Tipo da bateria: ${anu.merek_batre}`
 wew = fs.readFileSync('./logos/logo2.jpg')
await conn.sendMessage(from, {image: wew, thumbnail:null, caption: `${busca_celular}`}, {quoted: info})
break

case 'play':
qp = args.join(" ")
res = await yts(qp)
reply(enviar.espere)
blaimg = await getBuffer(res.all[0].image)

bla = `â˜‚ï¸ Titulo: ${res.all[0].title}\nğŸ“‰ VisualizaÃ§Ãµes: ${res.all[0].views}\nâ° Tempo: ${res.all[0].timestamp}\nğŸ” Canal: ${res.all[0].author.name}\n âš™ï¸ Se vocÃª nÃ£o conseguir visualizar os botÃµes, execute o play2 como segunda opÃ§Ã£o.`

sendBimg(from, `${res.all[0].image}`, bla, NomeDoBot, [
{buttonId: `${prefix}audioplay ${qp}`, buttonText: {displayText: `ğŸµ Audio`}, type: 1}, {buttonId: `${prefix}videoplay ${qp}`, buttonText: {displayText: `ğŸ¥ Video`}, type: 1}], info)
break 

case 'videoplay':
reply(enviar.espere)  
reply('Enviando, vai demorar um pouco, ok? ğŸ˜')  
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/playmp4?q=${q}&apikey=${keyale}`) 
audbla = await getBuffer(bla.resultado.url)
conn.sendMessage(from, {video: audbla, mimetype: 'video/mp4'}, {quoted: info}).catch(e => {
reply(`desculpe mas nÃ£o achei o que vocÃª quer / Ou / A api caiu, em breve volta.`)
})
break

case 'audioplay':
reply(enviar.espere)
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/playmp4?q=${q}&apikey=${keyale}`) 
audbla = await getBuffer(bla.resultado.url)
conn.sendMessage(from, {audio: audbla, mimetype: 'audio/mp4'}, {quoted: info}).catch(async (e) => { 
bli = yts(q)
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/ytmp3_2?url=${bli.all[0].url}&apikey=${keyale}`)
conn.sendMessage(from, {audio: bla, mimetype: 'audio/mp4'})
}).catch(async (e) => {
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/playv1?q=${q}&apikey=${keyale}`) 
audbla = await getBuffer(bla.resultado)
conn.sendMessage(from, {audio: audbla, mimetype: 'audio/mp4'}, {quoted: info})
}).catch(e => {
reply("Error, nÃ£o consigo baixar essa mÃºsica, nÃ£o sei pq ğŸ˜”")  
})
break

case 'play2':
playzin = args.join(" ") 
if(!playzin) return reply('Cade o nome da mÃºsica?')
reply(enviar.espere)
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/playmp4?q=${q}&apikey=${keyale}`) 
bla = bla.resultado
pla = `Titulo: ${bla.titulo}\n`
pla += `VisualizaÃ§Ãµes: ${bla.visu}\n`
pla += `Publicado : ${bla.publicado}\n\n`
pla += `Enviando o Ã¡udio, vai demorar pra caramba, OK?`
img = await getBuffer(bla.thumb)
conn.sendMessage(from, {image: img, caption: `${pla}`}, {quoted: info})
audbla = await getBuffer(bla.url)
conn.sendMessage(from, {audio: audbla, mimetype: 'audio/mp4'}, {quoted: info}).catch(e => {
reply(`desculpe mas nÃ£o achei o que vocÃª quer.`)
})
break

case 'play3':
qp = args.join(" ")
if(!qp) return reply(`Cade o nome da mÃºsica?`)
reply(enviar.espere)
res = await yts(qp)

blaimg = await getBuffer(res.all[0].image)

bla = `Titulo: ${res.all[0].title}\nVisualizaÃ§Ãµes: ${res.all[0].views}\nTempo: ${res.all[0].duration.timestamp}\nCanal: ${res.all[0].author.name}\n`

conn.sendMessage(from, {image: blaimg, caption: bla}, {quoted: info})
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/ytmp3-2?q=${res.all[0].url}&apikey=${keyale}`)
blabla = await getBuffer(bla[0].link)
conn.sendMessage(from, {audio: blabla, mimetype: 'audio/mp4'}, {quoted: info}).catch(e => {
reply('Error')
})
break


case 'playmp4':
qp = args.join(" ")
if(!qp) return reply(`Cade o nome da mÃºsica?/Video?`)
reply(enviar.espere)
res = await yts(qp)

blaimg = await getBuffer(res.all[0].image)

bla = `Titulo: ${res.all[0].title}\nVisualizaÃ§Ãµes: ${res.all[0].views}\nTempo: ${res.all[0].duration.timestamp}\nCanal: ${res.all[0].author.name}\n`

conn.sendMessage(from, {image: blaimg, caption: bla}, {quoted: info})
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/playmp4?q=${q}&apikey=${keyale}`) 
audbla = await getBuffer(bla.resultado.url)
conn.sendMessage(from, {video: audbla, mimetype: 'video/mp4'}, {quoted: info}).catch(e => {
reply('ERROR!')
})
break

//============(CASE-BEM-VINDO/E ETC..)=========\\

case 'bemvindo':
case 'welcome':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isWelkom) return reply('Ja esta ativo')
welkom.push(from)
fs.writeFileSync('./datab/grupos/welkom.json', JSON.stringify(welkom))
reply('ğŸŒ€ Ativou com sucesso o recurso de bem vindo neste grupo ğŸ“')
} else if (Number(args[0]) === 0) {
if (!isWelkom) return reply('Ja esta Desativado')
pesquisar = from
processo = welkom.indexOf(pesquisar)
while(processo >= 0){
welkom.splice(processo, 1)
processo = welkom.indexOf(pesquisar)
}
fs.writeFileSync('./datab/grupos/welkom.json', JSON.stringify(welkom))
reply('â€¼ï¸ Desativou com sucesso o recurso de bemvindo neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

//=====================================\\



//=================(ANTS)=================\\

case 'antictt':
case 'anticontato':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntiCtt) return reply('Ja esta ativo')
antictt.push(from)
fs.writeFileSync('./datab/ants/antictt.json', JSON.stringify(antictt))
reply('ğŸŒ€ Ativou com sucesso o recurso de anticontato neste grupo ğŸ“')
} else if (Number(args[0]) === 0) {
if (!isAntiCtt) return reply('Ja esta Desativado')
pesquisar = from
processo = antictt.indexOf(pesquisar)
while(processo >= 0){
antictt.splice(processo, 1)
processo = antictt.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antictt.json', JSON.stringify(antictt))
reply('â€¼ï¸ Desativou com sucesso o recurso de anticontato neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'anticatalogo':
case 'anticatalg':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAnticatalogo) return reply('Ja esta ativo')
anticatalogo.push(from)
fs.writeFileSync('./datab/ants/anticatalogo.json', JSON.stringify(anticatalogo))
reply('ğŸŒ€ Ativou com sucesso o recurso de anticatalogo neste grupo ğŸ“')
} else if (Number(args[0]) === 0) {
if (!isAnticatalogo) return reply('Ja esta Desativado')
pesquisar = from
processo = anticatalogo.indexOf(pesquisar)
while(processo >= 0){
anticatalogo.splice(processo, 1)
processo = anticatalogo.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/anticatalogo.json', JSON.stringify(anticatalogo))
reply('â€¼ï¸ Desativou com sucesso o recurso de anticatalogo neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antifake':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntifake) return reply('Ja esta ativo')
antifake.push(from)
fs.writeFileSync('./datab/ants/antifake.json', JSON.stringify(antifake))
reply('ğŸŒ€ Ativou com sucesso o recurso de antifake neste grupo ğŸ“')
} else if (Number(args[0]) === 0) {
if (!isAntifake) return reply('Ja esta Desativado')
pesquisar = from
processo = antifake.indexOf(pesquisar)
while(processo >= 0){
antifake.splice(processo, 1)
processo = antifake.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antifake.json', JSON.stringify(antifake))
reply('â€¼ï¸ Desativou com sucesso o recurso de antifake neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiloc':
if (!isGroup) return reply(` SOMENTE EM GRUPOS`)
if (!isGroupAdmins) return reply(`PRECISA SER ADMIN`)
if (!isBotGroupAdmins) return reply(` O BOT PRECISA SER ADMIN`)
try {														 
if (args.length < 1) return reply('1 pra ativar, 0 pra desligar')
if (Number(args[0]) === 1) {
if(Antiloc) return reply('JÃ¡ estÃ¡ Ativo.')
antiloc.push(from)
fs.writeFileSync('./datab/ants/antiloc.json', JSON.stringify(antiloc))
reply('Ativou com sucesso o recurso de anti loc neste grupoâœ”ï¸')
} else if (Number(args[0]) === 0) {
if(!Antiloc) return reply('JÃ¡ estÃ¡ Desativado.')
antiloc.splice(from, 1)
fs.writeFileSync('./datab/ants/antiloc.json', JSON.stringify(antiloc))
reply('Desativou com sucesso o recurso de anti loc neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
} catch {
reply('Deu erro, tente novamente :/')
}
break

case 'antidocumento':
if (!isGroup) return reply(` SOMENTE EM GRUPOS`)
if (!isGroupAdmins) return reply(`PRECISA SER ADMIN`)
if (!isBotGroupAdmins) return reply(` O BOT PRECISA SER ADMIN`)
try {														 
if (args.length < 1) return reply('1 pra ativar, 0 pra desligar')
if (Number(args[0]) === 1) {
antidoc.push(from)
fs.writeFileSync('./datab/ants/antidoc.json', JSON.stringify(antidoc))
reply('Ativou com sucesso o recurso de anti documento neste grupoâœ”ï¸')
} else if (Number(args[0]) === 0) {
antidoc.splice(from, 1)
fs.writeFileSync('./datab/ants/antidoc.json', JSON.stringify(antidoc))
reply('Desativou com sucesso o recurso de antidocumento neste grupoâœ”ï¸')
 } else {
reply('1 para ativar, 0 para desativar')
}
} catch {
reply('Deu erro, tente novamente :/')
}
break

case 'antiimg':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiImg) return reply('JÃ¡ Esta ativo')
antiimg.push(from)
fs.writeFileSync('./datab/ants/antiimg.json', JSON.stringify(antiimg))
reply('Ativou com sucesso o recurso de anti imagem neste grupoâœ”ï¸')
} else if (Number(args[0]) === 0) {
if (!isAntiImg) return reply('Ja esta Desativado.')
antiimg.splice(from, 1)
fs.writeFileSync('./datab/ants/antiimg.json', JSON.stringify(antiimg))
reply('Desativou com sucesso o recurso de anti imagem neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antisticker':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiSticker) return reply('JÃ¡ Esta ativo')
antisticker.push(from)
fs.writeFileSync('./datab/ants/antisticker.json', JSON.stringify(antisticker))
reply('Ativou com sucesso o recurso de anti sticker neste grupoâœ”ï¸')
} else if (Number(args[0]) === 0) {
if (!isAntiSticker) return reply('Ja esta Desativado.')
antisticker.splice(from, 1)
fs.writeFileSync('./datab/ants/antisticker.json', JSON.stringify(antisticker))
reply('Desativou com sucesso o recurso de anti sticker neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antinotas':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiNotas) return reply('JÃ¡ Esta ativo')
antinotas.push(from)
fs.writeFileSync('./datab/ants/antinotas.json', JSON.stringify(antinotas))
reply('Ativou com sucesso o recurso de anti notas neste grupoâœ”ï¸')
} else if (Number(args[0]) === 0) {
if (!isAntiNotas) return reply('Ja esta Desativado.')
antinotas.splice(from, 1)
fs.writeFileSync('./datab/ants/antinotas.json', JSON.stringify(antinotas))
reply('Desativou com sucesso o recurso de anti notas neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antivideo':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiVid) return reply('Ja esta ativo')
antivid.push(from)
fs.writeFileSync('./datab/ants/antivideo.json', JSON.stringify(antivid))
reply('Ativou com sucesso o recurso de anti video neste grupoâœ”ï¸')
} else if (Number(args[0]) === 0) {
if (!isAntiVid) return reply('Ja esta Desativado')
antivid.splice(from, 1)
fs.writeFileSync('./datab/ants/antivideo.json', JSON.stringify(antivid))
reply('Desativou com sucesso o recurso de anti video neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiaudio':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiAudio) return reply('Ja esta ativo')
antiaudio.push(from)
fs.writeFileSync('./datab/ants/antiaudio.json', JSON.stringify(antiaudio))
reply('Ativou com sucesso o recurso de anti audio neste grupoâœ”ï¸')
} else if (Number(args[0]) === 0) {
if (!isAntiAudio) return reply('Ja esta Desativado')  
antiaudio.splice(from, 1)
fs.writeFileSync('./datab/ants/antiaudio.json', JSON.stringify(antiaudio))
reply('Desativou com sucesso o recurso de anti audio neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'limitecaracteres':
case 'limiteflood':  
if (!isGroup) return reply(enviar.msg.adm)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar. info.Badmin)
if (args.length < 1) return reply(`Digite ${prefix + command} 1 para ativar`)
if (Number(args[0]) === 1) {
if (isAntiFlood) return reply(`ğŸŒ€ O recurso limite de caracteres atÃ© ${limitefl} jÃ¡ estÃ¡ ativo no grupo ğŸŒ€`)
antiflood.push(from)
fs.writeFileSync('./datab/usuarios/antiflood.json', JSON.stringify(antiflood))
reply(`âœ”ï¸ O recurso limite de caracteres ${limitefl} foi ativado nesse grupoğŸ“`)
} else if (Number(args[0]) === 0) {
 if (!isAntiFlood) return reply('âœ”ï¸ O recurso limite de caracteres nÃ£o estÃ¡ ativado no grupo ğŸ“')
let position = false
Object.keys(antiflood).forEach((i) => {
if (antiflood[i] === from) {
position = i
}
})
if (position !== false) {
antiflood.splice(position, 1)
fs.writeFileSync('./datab/usuarios/antiflood.json', JSON.stringify(antiflood))
}
reply('O recurso limite de caracteres foi desativado nesse grupo âœ”ï¸')
} else {
reply(`Digite ${prefix + command} 1 para ativar, 0 para desativar o recurso`)
}
break

case 'resetarttt':
case 'rvttt':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
daily.splice([])
fs.writeFileSync('./datab/usuarios/diario.json', JSON.stringify(daily))
reply('â€¼ï¸O jogo da velha TTT foi resetado com sucesso..âœ”ï¸')
reply(`${prefix}reiniciar`)
break

case 'reiniciar':
if(!SoDono) return
rp = (Date.now() / 1000) - info.messageTimestamp
blar = process.uptime()
startAle()
reply(`Reiniciei em ${String(rp.toFixed(3))}m\n\nTempo Ativo : ${kyun(blar)}`)
break
 
case 'antilink':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntiLink) return reply('Ja esta ativo')
antilink.push(from)
fs.writeFileSync('./datab/ants/antilink.json', JSON.stringify(antilink))
reply('ğŸŒ€ Ativou com sucesso o recurso de antilink neste grupo ğŸ“')
} else if (Number(args[0]) === 0) {
if (!isAntiLink) return reply('Ja esta Desativado')
pesquisar = from
processo = antilink.indexOf(pesquisar)
while(processo >= 0){
antilink.splice(processo, 1)
processo = antilink.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antilink.json', JSON.stringify(antilink))
reply('â€¼ï¸ Desativou com sucesso o recurso de antilink neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antipalavrÃ£o':
case 'antipalavrao':  
if (!isGroup) return reply(`[â—] SOMENTE EM GRUPOS`)
if (!isGroupAdmins) return reply(`[â—] O PRECISA SER ADMIN`)
if (!isBotGroupAdmins) return reply(`[â—] O BOT PRECISA SER ADMIN`)
if (args.length < 1) return reply(`[â—] 1 / 0, Exemplo ${prefix + command} 1`)
if (Number(args[0]) === 1) {
if (isPalavrao) return reply('*JÃ¡ esta ativado...*')
palavrao.push(from)
fs.writeFileSync('./datab/grupos/palavrao.json', JSON.stringify(palavrao))
reply(`[â—] anti palavrÃ£o ativado`)
} else if (Number(args[0]) === 0) {
if (!isPalavrao) return reply('*JÃ¡ esta Desativado...*')  
palavrao.splice(from, 1)
fs.writeFileSync('./datab/grupos/palavrao.json', JSON.stringify(palavrao))
reply(`[â—] anti palavrÃ£o desativado...`)
} else {
reply(`[â—] 1 / 0, Exemplo ${prefix + command} 0`)
}
await limitAdd(sender)
break

case 'antilinkhard':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntiLinkHard) return reply('Ja esta ativo')
antilinkhard.push(from)
fs.writeFileSync('./datab/ants/antilinkhard.json', JSON.stringify(antilinkhard))
reply('ğŸŒ€ Ativou com sucesso o recurso de antilink hardcore neste grupo ğŸ“')
} else if (Number(args[0]) === 0) {
if (!isAntiLinkHard) return reply('Ja esta Desativado')
pesquisar = from
processo = antilinkhard.indexOf(pesquisar)
while(processo >= 0){
antilinkhard.splice(processo, 1)
processo = antilinkhard.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antilinkhard.json', JSON.stringify(antilinkhard))
reply('â€¼ï¸ Desativou com sucesso o recurso de antilink harcore neste grupoâœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antilinkgp':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntilinkgp) return reply('Ja esta ativo')
antilinkgp.push(from)
fs.writeFileSync('./datab/ants/antilinkgp.json', JSON.stringify(antilinkgp))
reply('ğŸŒ€ Ativou com sucesso o recurso de antilinkgp ğŸ“')
} else if (Number(args[0]) === 0) {
if (!isAntilinkgp) return reply('Ja esta Desativado')
pesquisar = from
processo = antilinkgp.indexOf(pesquisar)
while(processo >= 0){
antilinkgp.splice(processo, 1)
processo = antilinkgp.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antilinkgp.json', JSON.stringify(antilinkgp))
reply('â€¼ï¸ Desativou com sucesso o recurso de antilink de grupo âœ”ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'bemvindo2':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply(`Digite da forma correta:\nComando: ${prefix + command} 1 para ativar `)
if (Number(args[0]) === 1) {
reply(`Devo Lembrar que vocÃª deve determinar a legenda desse grupo, apÃ³s ativar essa funÃ§Ã£o, a legenda funciona por grupo, se deseja saber mais informaÃ§Ãµes sobre, digite ${prefix}infobemvindo`)  
if (isWelkom2) return reply('âO recurso jÃ¡ estÃ¡ ativado no grupoâ')
welkom2.push(from)
fs.writeFileSync('./datab/usuarios/vacilo.json', JSON.stringify(welkom2))
reply('âœ…O recurso foi ativadoâœ…')
} else if (Number(args[0]) === 0) {
if (!isWelkom2) return reply('âO recurso nÃ£o estÃ¡ ativado no grupoâ')
let position = false
Object.keys(welkom2).forEach((i) => {
if (welkom2[i] === from) {
position = i
}
})
if (position !== false) {
welkom2.splice(position, 1)
fs.writeFileSync('./datab/usuarios/vacilo.json', JSON.stringify(welkom2))
}
reply('âŒO recurso foi desativadoâŒ')
} else {
reply(`Digite da forma correta:\nComando: ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

//==========(Sticker-Stickers)===========\\

case 'emoji':
case 'semoji':
if(!q) return reply(`Exemplo: ${prefix}emoji â˜¹ï¸/whatsapp`)
emot = q.split('/')[0]
jemot = q.split('/')[1]
if(jemot == 'apple'){
idemot = 0
}
else if(jemot == 'google'){
idemot = 1
}
else if(jemot == 'samsung'){
idemot = 2
}
else if(jemot == 'microsoft'){
idemot = 3
}
else if(jemot == 'whatsapp'){
idemot = 4
}
else if(jemot == 'twitter'){
idemot = 5
}
else if(jemot == 'facebook'){
idemot = 6
}
else if(jemot == 'joypixels'){
idemot = 7
}
else if(jemot == 'openmoji'){
idemot = 8
}
else if(jemot == 'emojidex'){
idemot = 9
}
else if(jemot == 'lg'){
idemot = 10
}
else if(jemot == 'htc'){
idemot = 11
}
else if(!jemot){
idemot = 4
}
else{
return reply(`Exemplo: ${prefix}emoji â˜¹ï¸/whatsapp`)
}
reply(enviar.espere)
if(idemot == undefined) return
emoji.get(emot)
.then(emoji => {
console.log(emoji.images[idemot]);
sendStickerFromUrl(from, emoji.images[idemot].url, info)
}).catch(e => {
reply("EMOJI NÃƒO ENCONTRADO, TENTE OUTRO EMOJI..")
})
break

case 'sc':
case 'c':  
case 'csticker':  
case 'cstiker':  
case 'stcirculo':
case 'circlesticker':  
if ((isMedia && info.message.imageMessage || isQuotedImage) && args.length == 0) {
const encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
media = rane
getpunt = getRandom('.png')
inpunt = getRandom('.webp')
exec(`convert ${media} -resize 512x512^ -gravity center -extent 512x512 ${getpunt} && magick ${getpunt} -quality 50 -define webp:lossless=true ${inpunt}`, async (error) => {
fs.unlinkSync(getpunt)
fs.unlinkSync(media)
if (error) return reply("Error!")
await conn.sendMessage(from, {sticker: fs.readFileSync(inpunt)}, {quoted: info})
fs.unlinkSync(inpunt)
})
} else {
reply("Apenas image!")
}
break

case 'fstiker': 
case 'fsticker':
case 'f':
await limitAdd(sender)
if ((isMedia && !info.message.videoMessage || isQuotedImage) && args.length == 0) {
const encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
const media = rane
ran = getRandom('.webp')
await ffmpeg(`./${media}`)
.input(media)
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
fs.unlinkSync(media)
reply(enviar.stikga)
})
.on('end', function () {
console.log('Finish')
buffer = fs.readFileSync(ran)
conn.sendMessage(from, {sticker: buffer}, {quoted: info})
fs.unlinkSync(media)
fs.unlinkSync(ran)
})
.addOutputOptions([`-vcodec`,`libwebp`,`-vf`,`scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`])
.toFormat('webp')
.save(ran)
} else if ((isMedia && info.message.videoMessage.seconds < 10 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 10) && args.length == 0) {
const encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
const media = rane
ran = getRandom('.webp')
reply(enviar.espere) 
await ffmpeg(`./${media}`)
.inputFormat(media.split('.')[1])
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
fs.unlinkSync(media)
tipe = media.endsWith('.mp4') ? 'video' : 'gif'
reply(enviar.stikga)
})
.on('end', function () {
console.log('Finish')
buffer = fs.readFileSync(ran)
conn.sendMessage(from, {sticker: buffer}, {quoted: info})
fs.unlinkSync(media)
fs.unlinkSync(ran)
})
.addOutputOptions([`-vcodec`,`libwebp`,`-vf`,`scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`])
.toFormat('webp')
.save(ran)
} else {
reply(`Enviar imagem / vÃ­deo / gif com legenda \n${prefix}sticker (duraÃ§Ã£o do adesivo de vÃ­deo de 1 a 9 segundos)`)
}
break 

case 'emoji-mix':
case 'emojimix':
try {
textoo = args.join(' ')
textoo1 = textoo.split('+')[0]
textoo2 = textoo.split('+')[1]
bau = require('./armor/emoji.js')
sitee = bau.Semoji(textoo1, textoo2)
bala = await getBuffer(sitee)
fs.writeFileSync('./imagem.webp', bala)
site = fs.readFileSync('./imagem.webp')
bass64 = `data:image/jpeg;base64,${site.toString('base64')}`
mantap = await convertSticker(bass64, `Aleatory - MD`, `Aleatory`)
imageBuffer = new Buffer.from(mantap, 'base64');
conn.sendMessage(from, {sticker: imageBuffer}, {quoted: info})
fs.unlinkSync('./imagem.webp')
} catch {
reply('*Ops nÃ£o foi possivel fazer esse mix de emoji...*')
}
break

case 'st':
case 'st':
case 'sticker':
case 's':
try {
if ((isMedia && !info.message.videoMessage || isQuotedImage) && args.length == 0) {
const encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
const media = rane
rano = getRandom('.webp')
reply(enviar.espere)
await ffmpeg(`./${media}`)
.input(media)
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
exec(`webpmux -set exif ${addMetadata('bot','ale')} ${rano} -o ${rano}`, async (error) => {
fs.unlinkSync(media)
reply(enviar.stick)
})
})
exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${rano}`, (err) => {
fs.unlinkSync(media)
buffer = fs.readFileSync(rano)
conn.sendMessage(from, {sticker: buffer}, {quoted: info})
fs.unlinkSync(rano)
})
} else if ((isMedia && info.message.videoMessage.seconds < 11 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 11) && args.length == 0) {
const encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
const media = rane
rano = getRandom('.webp')
await ffmpeg(`./${media}`)
.inputFormat(media.split('.')[1])
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
exec(`webpmux -set exif ${addMetadata('bot', 'ale')} ${rano} -o ${rano}`, async (error) => {
fs.unlinkSync(media)
tipe = media.endsWith('.mp4') ? 'video' : 'gif'
reply(`Falha na conversÃ£o de ${tipe} para sticker`)
})
})
exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 200:200 ${rano}`, (err) => {
fs.unlinkSync(media)
buffer = fs.readFileSync(rano)
conn.sendMessage(from, {sticker: buffer}, {quoted: info})
fs.unlinkSync(rano)
})
} else {
reply(`VocÃª precisa enviar ou marcar uma imagem ou vÃ­deo com no mÃ¡ximo 10 segundos`)
}
} catch {
reply('Ocorreu algum Error, desculpe ğŸ˜”')
}
break

case 'toimg':
if (!isQuotedSticker) return reply('âŒ adesivo de resposta um âŒ')
reply(enviar.espere)
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
conn.sendMessage(from, {image: buff}, {quoted: info}).catch(e => {
console.log(e);
reply('ERROR!!')
})
break

//=============(LOGOS)=============\\



//==========(PLAQUINHAS-LOGOS)===========\\

case 'plaq': //by zanga 
if (!isNsfw) return reply(`Ã‰ necessÃ¡rio que o comando seja ativado por um adm\nExemplo: ${prefix}nsfw 1`)
if (args.length < 1) return reply(`${prefix}plaq e digite o seu nome`)
teks = body.slice(6)
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres') //maximo de caracteres
reply(enviar.espere) //mensagem
buffer = await getBuffer(`https://raptibef.sirv.com/images%20(3).jpeg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=19%25&text.0.size=45&text.0.color=000000&text.0.opacity=55&text.0.font.family=Crimson%20Text&text.0.font.weight=300&text.0.font.style=italic&text.0.outline.opacity=21`)
if(verificado === true) {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: selo})
} else {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: info})  
}
break

case 'plaq2': //by zanga 
if (!isNsfw) return reply(`Ã‰ necessÃ¡rio que o comando seja ativado por um adm\nExemplo: ${prefix}nsfw 1`)
if (args.length < 1) return reply(`${prefix}plaq2 e digite o seu nome`)
teks = body.slice(7)
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres') //maximo de caracteres
reply(enviar.espere) //mensagem
buffer = await getBuffer(`https://raptibef.sirv.com/images%20(1).jpeg?profile=Zanga%202.0&text.0.text=${teks}`)
if(verificado === true) {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: selo})
} else {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: info}) 
}
break

case 'plaq3': //by zanga
if (!isNsfw) return reply(`Ã‰ necessÃ¡rio que o comando seja ativado por um adm\nExemplo: ${prefix}nsfw 1`)
if (args.length < 1) return reply(`${prefix}plaq3 e digite o seu nome`)
teks = body.slice(7)
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres') //maximo de caracteres
reply(enviar.espere) //mensagem
buffer = await getBuffer(`https://raptibef.sirv.com/images.jpeg?profile=Zanga%203.0&text.0.text=${teks}&text.0.outline.blur=63`)
if(verificado === true) {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: selo})
} else {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: info}) 
}
break

case 'plaq4':
if (!isNsfw) return reply(`Ã‰ necessÃ¡rio que o comando seja ativado por um adm\nExemplo: ${prefix}nsfw 1`) 
if (args.length < 1) return reply(`${prefix}plaq7 e digite o seu nome`)
teks = body.slice(7)
if (teks.length > 10) return reply('O texto Ã© longo, atÃ© 10 caracteres') //maximo de caracteres
reply(enviar.espere) //mensagem
buffer = await getBuffer(`https://umethroo.sirv.com/Torcedora-da-sele%C3%A7%C3%A3o-brasileira-nua-mostrando-a-bunda-236x300.jpg?text.0.text=${teks}&text.0.position.x=-64%25&text.0.position.y=-39%25&text.0.size=25&text.0.color=1b1a1a&text.0.font.family=Architects%20Daughter`) //api
plaq = ` *Plaquinha feita âœ“* `
if(verificado === true) {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: selo})
} else {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: info}) 
}
break

case 'plaq5':
if (!isNsfw) return reply(`Ã‰ necessÃ¡rio que o comando seja ativado por um adm\nExemplo: ${prefix}nsfw 1`)
if (args.length < 1) return reply(`${prefix}plaq10 e digite o seu nome`)
teks = body.slice(7)
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres') //maximo de caracteres
reply(enviar.espere) //mensagem
buffer = await getBuffer(`https://umethroo.sirv.com/peito1.jpg?text.0.text=${teks}&text.0.position.x=-4%25&text.0.position.y=-6%25&text.0.size=14&text.0.color=000000&text.0.font.family=Shadows%20Into%20Light&text.0.font.weight=700`)
if(verificado === true) {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: selo})
} else {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: info}) 
}
break
case 'plaq4off': //by zanga
if (!isNsfw) return reply(`Ã‰ necessÃ¡rio que o comando seja ativado por um adm\nExemplo: ${prefix}nsfw 1`)
if (args.length < 1) return reply(`${prefix}plaq4 e digite o seu nome`)
teks = body.slice(7)
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres') //maximo de caracteres
reply(enviar.espere) //mensagem
buffer = await getBuffer(`https://raptibef.sirv.com/images%20(2).jpeg?profile=Zanga%204.0&text.0.text=${teks}`)
if(verificado === true) {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: selo})
} else {
conn.sendMessage(from, {image: buffer, sendEphemeral: true, thumbnail: null, caption: ' *Plaquinha feita âœ“* '}, {quoted: info}) 
}
break

case 'placaloli':
if (!q) return reply(enviar.wrongFormat)
reply('Aguarde..')
lod = await fetchJson(`https://nekobot.xyz/api/imagegen?type=kannagen&text=${q}`)
sendStickerFromUrl(from, lod.message, enviar.success)
await limitAdd(sender)
break 

//=======================================\\


// LOGOS 

case 'shadow':
case 'angelwing':
case 'efeitoneon':
case 'cemiterio':
case 'metalgold':
case 'narutologo':
case 'fire':
case 'romantic':
case 'smoke':  
case 'papel':
case 'lovemsg':
case 'lovemsg2':
case 'lovemsg3':
case 'coffecup':
case 'coffecup2':  
case 'cup':
case 'florwooden':
case 'madeira':
case 'neon2':
case 'lobometal':
case 'harryp':
case 'txtborboleta':
case 'blackpink':
case 'girlmascote': 
case 'logogame':
case 'equipemascote':
case 'fpsmascote':
case 'hackneon':
case 'ffavatar':
case 'mascotegame':
case 'wingeffect':
case 'angelglx':
case 'gizquadro':
case 'txtquadrinhos':
textin = args.join(" ")
if(!textin) return reply("Cade o texto?")
reply(enviar.espere)
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/${command}?texto=${textin}&apikey=${keyale}`)
blabla = await getBuffer(bla.resultado.imageUrl)
conn.sendMessage(from, {image: blabla}, {quoted: info}).catch(rs =>{
reply("ERROR!!")  
})
break  

case 'gameplay':
case 'ffbanner':
case 'mascoteavatar':  
textin = args.join(" ")
txt1 = textin.split("/")[0];
txt2 = textin.split("/")[1];
if(!textin) return reply("Cade o texto?")
if(!textin.includes("/")) return reply(`Cade a / precisa dela para a separaÃ§Ã£o..\nExemplo: ${prefix + command} Game/Play`)
reply(enviar.espere)
bla = await fetchJson(`https://aleatoryapi.herokuapp.com/api/${command}?texto=${txt1}&texto2=${txt2}&apikey=${keyale}`)
blabla = await getBuffer(bla.resultado.imageUrl)
conn.sendMessage(from, {image: blabla}, {quoted: info}).catch(rs =>{
reply("ERROR!!")  
})
break

case 'googlesg':
textin = args.join(" ")
txt1 = textin.split("/")[0];
txt2 = textin.split("/")[1];
txt3 = textin.split("/")[2];
if(!textin) return reply("Cade o texto?")
if(!textin.includes("/")) return reply(`Cade a / precisa dela para a separaÃ§Ã£o..\nExemplo: ${prefix + command} Game/Play/Sad`)
reply(enviar.espere)
bla = await fetchJson(`http://aleatoryapi.herokuapp.com/api/${command}?texto=${txt1}&texto2=${txt2}&texto3=${txt3}&apikey=${keyale}`)
blabla = await getBuffer(bla.resultado.imageUrl)
conn.sendMessage(from, {image: blabla}, {quoted: info}).catch(rs =>{
reply("ERROR!!")  
})
break  

case 'marvel': 
case 'glitch':   
case 'stone':   
case 'space':
case 'pornhub':
case 'america':   
case 'steel':  
case 'grafity':  
case 'glitch3':  
try {
texto = args.join(' ')
texto1 = texto.split('/')[0] || 'Indefinido'
texto2 = texto.split('/')[1] || 'Indefinido'
if(!texto.includes("/")) return reply(`Cade a /\nExemplo: ${prefix + command} sad/sad`)
reply(enviar.espere)
bla = await fetchJson(`http://aleatoryapi.herokuapp.com/api/${command}?texto=${texto1}&texto2=${texto2}&apikey=${keyale}`)
blabla = await getBuffer(bla.resultado)
conn.sendMessage(from, {image: blabla}, {quoted: info})
} catch {
reply('ERROR!!')
}
break

case 'lava':
case 'toxic':  
case 'thunder': 
case 'thunderv2':  
case 'neongreen':	
case 'neon':  
case 'neon1':  
case 'neon3d':  
case 'demongreen':   
case 'metalfire':  
case 'rainbow':	  
case 'gelo':
case 'halloween':  
case 'lapis':  
case 'glitch':  
case 'glitch2':   
case '3dgold': 
case 'neon3d':   
case 'transformer':  
case '3dstone':
case 'fiction':
case 'cattxt':
case 'neondevil':
case 'demonfire':
case 'colaq':
case 'luxury':
case 'berry':
case 'matrix':
case 'horror':
case 'nuvem':
case 'neon3':
case 'neve':
case 'areia':
case 'vidro':
case 'style':
case 'blood':
case 'pink':
case 'carbon':
case 'metalblue': 
case 'jeans':  
case 'jokerlogo':   
case 'natal': 
case 'ossos':  
case 'asfalto':	
case 'break':  
try {
reply(enviar.espere)
texto = args.join(" ") || 'Indefinido'
if(!texto) return reply('Cade o texto?')
bla = await fetchJson(`http://aleatoryapi.herokuapp.com/api/${command}?texto=${texto}&apikey=${keyale}`)
blabla = await getBuffer(bla.resultado)
conn.sendMessage(from, {image: blabla}, {quoted: info})
} catch {
reply('ERROR')
}
break

//========(SORTEIO-VOTAR-CASES)=========\\

case 'delvote':
case 'delvoto':  
if(!info.key.remoteJid) return
delVote(from)
reply('votaÃ§Ã£o deletada com sucesso')
break

case 'votar':
case 'votacao': 
case 'votaÃ§Ã£o': 
if(!isGroup) return reply(enviar.msg.grupo)
if(!budy.includes("/")) return reply(`Cade a /, exemplo ${prefix}votaÃ§Ã£o @marca/Ele Ã© total gay/ 1`)
if(!q) return reply('*VotaÃ§Ã£o*\n\n'+ prefix+ 'votar @tag marcar / pergunta  / 1 (1 = 1 Minuto)')
if (info.message.extendedTextMessage.contextInfo.mentionedJid.length > 0 || info.message.extendedTextMessage.contextInfo == null) {
let id = info.message.extendedTextMessage.contextInfo.mentionedJid[0]
split = args.join(' ').replace('@', '').split('/')
if(!Number(split[2])) return reply('cade os minutos eim?\n\n1 = 1 Minuto')
await mentions('Vote ' +'@'+ id.split('@')[0]+' para' +'\n\n' + `voto = âœ…\ndevoto = âŒ\n\npergunta: ${split[1]}`,[id],true)
addVote(from,split[1],split[0],split[2],reply)
}
break

case 'infosorteio':
case 'helpsorteio':  
if(verificado === true) {
await conn.sendMessage(from, {text:  infosorteio(prefix, pushname)}, {quoted: selo})
} else {
await conn.sendMessage(from, {text:  infosorteio(prefix, pushname)}, {quoted: info})  
}
break

case 'promover': 
if(!isGroupAdmins) return reply('SÃ³ ADM pode utilizar este comando.')
if(!isBotGroupAdmins) return reply('O Bot Precisa ser ADM pra executar essa aÃ§Ã£o.')
teks = body.slice(11)
if(teks.length > 15) return reply('SÃ³ pode promover uma pessoa por vez..')
await sleep(2000)
reply(`@${teks} Foi promovido(a) para adm com sucesso.`)
conn.groupParticipantsUpdate(from, [`${teks}@s.whatsapp.net`], "promote")
break

case 'rebaixar': 
if(!isGroupAdmins) return reply('SÃ³ ADM pode utilizar este comando.')
if(!isBotGroupAdmins) return reply('O Bot Precisa ser ADM pra executar essa aÃ§Ã£o.')
teks = body.slice(11)
if(teks.length > 15) return reply('SÃ³ pode rebaixar uma pessoa por vez..')
await sleep(2000)
reply(`@${teks} Foi Rebaixado(a) para membro comum com sucesso...`)
conn.groupParticipantsUpdate(from, [`${teks}@s.whatsapp.net`], "demote")
break

case 'sorteio':
if(!isGroupAdmins) return reply('SÃ³ ADM pode utilizar este comando.')
try{
if(!isGroup) return reply(enviar.msg.grupo)
if(!q) return reply(`Coloque algo, apÃ³s o comando sorteio, por exemplo, ${prefix}sorteio de 100 R$`)
d = []
teks = `ğŸ‰ParabÃ©ns, por ganhar o sorteio ${q}:\n\n`
for(i = 0; i < 1; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `ğŸ”¥áâƒŸÂ Â â£ @${groupMembers[r].id.split('@')[0]}\n`
d.push(groupMembers[r].id)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro, tente novamente :/')
}
break

case 'sorteionumero':
case 'sorteionumeros':  
if(!isGroupAdmins) return reply('SÃ³ ADM pode utilizar este comando.')  
try{
if(!isGroup) return reply(enviar.msg.grupo)
if(!q) return reply(`Coloque algo, apÃ³s o comando sorteio, por exemplo, ${prefix}sorteionumero de 100 R$`)
var numerossrt = sortear[Math.floor(Math.random() * sortear.length)] 
d = []
teks =  `ğŸ‰ParabÃ©ns ao nÃºmero do sortudo, por ganhar o sorteio ${q}:\n\n`
for(i = 0; i < 1; i++) {
teks += `ğŸ”¥áâƒŸÂ Â â£ ${numerossrt}\n`
d.push(numerossrt)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro, tente novamente :/')
}
break
//======================================\\



//==========(TTPS/ATTP/TTM)============\\

case 'attp':
if (args.length == 0) return reply(`Exemplo: ${prefix + command} Sad`)
reply(enviar.espere)
buffer = await getBuffer(`https://api.xteam.xyz/attp?file&text=${encodeURI(q)}`)
await conn.sendMessage(from, {sticker: buffer}, {quoted: info}).catch(e => {
reply('ERROR, ALGUM PROBLEMA NA API, EU ACHO.. ')  
})
break

case 'ttp':
try {
reply(enviar.espere)
string = args.join(' ') || 'Texto indefinido'
post = `http://aleatoryapi.herokuapp.com/api/ttp?texto=${string}&apikey=${keyale}`
sendStickerFromUrl(from, post, {quoted: info})
} catch {
reply('ERROR!!')
}
break

case 'attp2':		
case 'attp3': 
case 'attp4':
case 'attp5': 
case 'attp6':  
try {
if (args.length < 1) return reply(`_Coloque o texto _\n\n*Exemplo ${prefix}attp Sad`)
reply(enviar.espere)
url = await getBuffer(`http://brizas-api.herokuapp.com/ttp/${command}?apikey=brizaloka&text=${encodeURI(q)}`)
await conn.sendMessage(from, {sticker: url}, {quoted: info})
} catch {
reply('ERROR')
}
break	


//======================================\\


//===(ZOUEIRAS/BRINCADEIRAS/HUMOR)===\\

case 'modonsfw':
case 'nsfw':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isNsfw) return reply('O modo nsfw jÃ¡ estÃ¡ ativo')
nsfw.push(from)
fs.writeFileSync('./datab/grupos/nsfw.json', JSON.stringify(nsfw))
reply(`\`\`\`âœ“Ativado com sucesso o modo nsfw +18 no grupo\`\`\` *${groupMetadata.subject}*`)
} else if (Number(args[0]) === 0) {
if (!isNsfw) return reply('O modo nsfw jÃ¡ estÃ¡ Desativado')  
nsfw.splice(from, 1)
fs.writeFileSync('./datab/grupos/nsfw.json', JSON.stringify(nsfw))
reply(`\`\`\`âœ“Modo Nsfw +18 desativado com sucesso no grupo\`\`\` *${groupMetadata.subject}*`)
} else {
reply('1 para ativar, 0 para desligar')
}
break 

case 'modobrincadeira':
case 'modobrincadeiras':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isModobn) return reply('o modobrincadeira jÃ¡ estÃ¡ ativo')
modobn.push(from)
fs.writeFileSync('./datab/grupos/brincadeiras.json', JSON.stringify(modobn))
reply(`\`\`\`âœ“Ativado com sucesso o modobrincadeiras no grupo\`\`\` *${groupMetadata.subject}*`)
} else if (Number(args[0]) === 0) {
if (!isModobn) return reply('o modobrincadeira jÃ¡ estÃ¡ Desativado')  
modobn.splice(from, 1)
fs.writeFileSync('./datab/grupos/brincadeiras.json', JSON.stringify(modobn))
reply(`\`\`\`âœ“Modo brincadeiras desativado com sucesso no grupo\`\`\` *${groupMetadata.subject}*`)
} else {
reply('1 para ativar, 0 para desligar')
}
break 

case 'nick':
case 'gerarnick':
case 'fazernick':
nick = args.join(' ')
if(!nick) return reply('Escreva o Nick ou nome que vocÃª quer personalizar.')
axios.get(`https://aleatoryapi.herokuapp.com/api/fazernick?nome=${nick}&apikey=${keyale}`)
.then(dados => {
const emoji = `ğŸ”®`
nicks = dados.data
txt = 'ğŸ’ˆNicks Gerados Com Sucesso!ğŸ’ˆ\n\n'
for (let i = 0; i < nicks.length; i++) {
txt += `${emoji} ${nicks[i]}\n`
}
txt += `\n\n
â£   â–‰â•‘â–ˆâ–â–‰â–‰â–â–â–â–ˆâ•‘â–â–‰â–â–â–
â£   â–‰â•‘â–ˆâ–â–‰â–‰â–â–â–â–ˆâ•‘â–â–‰â–â–â–`
reply(`${txt.trim()}`)
}).catch(e => {
reply('NÃ£o pode incluir letras modificadas nem emojis, ou pode ser que a api caiu, mas volta logo logo...')  
})
break

case 'pl':
anu = await getBuffer('https://telegra.ph/file/0855427ea91c9c74eb290.mp4')
conn.sendMessage(from, {video: anu, mimetype: 'video/mp4'}, {quoted: info})
break

case 'chance':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)  
var avb = body.slice(7)
if (args.length < 1) return conn.sendMessage(from, {text: `VocÃª precisa digitar da forma correta\nExemplo: ${prefix}chance do luuck ser gay`}, {quoted: info})
random = `${Math.floor(Math.random() * 100)}`
hasil = `A chance ${body.slice(8)}\n\nÃ© de... ${random}%`
await conn.sendMessage(from, {text: hasil, contextInfo: {mentionedJid: [sender]}}, {quoted: info})
break

case 'gay':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
rate = body.slice(5)
reply(' â° Pesquisando a sua ficha de gay : '+rate+' aguarde... â±')
 setTimeout(async() => {
wew = await getBuffer(`${imggay}`)
zxzz = 
random = `${Math.floor(Math.random() * 110)}`
feio = random
boiola = random
if (boiola < 20 ) {bo = 'hmm... vocÃª Ã© heteroğŸ˜”'} else if (boiola == 21 ) {bo = '+/- boiola'} else if (boiola == 23 ) {bo = '+/- boiola'} else if (boiola == 24 ) {bo = '+/- boiola'} else if (boiola == 25 ) {bo = '+/- boiola'} else if (boiola == 26 ) {bo = '+/- boiola'} else if (boiola == 27 ) {bo = '+/- boiola'} else if (boiola == 2 ) {bo = '+/- boiola'} else if (boiola == 29 ) {bo = '+/- boiola'} else if (boiola == 30 ) {bo = '+/- boiola'} else if (boiola == 31 ) {bo = 'tenho minha desconfianÃ§a...ğŸ˜‘'} else if (boiola == 32 ) {bo = 'tenho minha desconfianÃ§a...ğŸ˜‘'} else if (boiola == 33 ) {bo = 'tenho minha desconfianÃ§a...ğŸ˜‘'} else if (boiola == 34 ) {bo = 'tenho minha desconfianÃ§a...ğŸ˜‘'} else if (boiola == 35 ) {bo = 'tenho minha desconfianÃ§a...ğŸ˜‘'} else if (boiola == 36 ) {bo = 'tenho minha desconfianÃ§a...ğŸ˜‘'} else if (boiola == 37 ) {bo = 'tenho minha desconfianÃ§a...ğŸ˜‘'} else if (boiola == 3 ) {bo = 'tenho minha desconfianÃ§a...ğŸ˜‘'} else if (boiola == 39 ) {bo = 'tenho minha desconfianÃ§a...ğŸ˜‘'} else if (boiola == 40 ) {bo = 'tenho minha desconfianÃ§a...ğŸ˜‘'} else if (boiola == 41 ) {bo = 'vocÃª Ã© nÃ©?ğŸ˜'} else if (boiola == 42 ) {bo = 'vocÃª Ã© nÃ©?ğŸ˜'} else if (boiola == 43 ) {bo = 'vocÃª Ã© nÃ©?ğŸ˜'} else if (boiola == 44 ) {bo = 'vocÃª Ã© nÃ©?ğŸ˜'} else if (boiola == 45 ) {bo = 'vocÃª Ã© nÃ©?ğŸ˜'} else if (boiola == 46 ) {bo = 'vocÃª Ã© nÃ©?ğŸ˜'} else if (boiola == 47 ) {bo = 'vocÃª Ã© nÃ©?ğŸ˜'} else if (boiola == 4 ) {bo = 'vocÃª Ã© nÃ©?ğŸ˜'} else if (boiola == 49 ) {bo = 'vocÃª Ã© nÃ©?ğŸ˜'} else if (boiola == 50 ) {bo = 'vocÃª Ã© ou nÃ£o?ğŸ§'} else if (boiola > 51) {bo = 'vocÃª Ã© gayğŸ™ˆ'
}
await conn.sendMessage(from, {image: wew, caption: '  O quanto vocÃª Ã© gay? \n\n ã€Œ '+rate+' ã€VocÃª Ã©: â° '+random+'% â± gay ğŸ³ï¸â€ğŸŒˆ\n\n '+bo+' ', thumbnail:null}, {quoted: info})
}, 7000)
break

case 'feio':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
rate = body.slice(6)
reply(' â° Pesquisando a sua ficha de feio : '+rate+', aguarde... â±')
 setTimeout(async() => {
wew = await getBuffer(`${imgfeio}`)
zxzz = 
random = `${Math.floor(Math.random() * 110)}`
feio = random
if (feio < 20 ) {bo = 'Ã‰ nÃ£o Ã© feio'} else if (feio == 21 ) {bo = '+/- feio'} else if (feio == 23 ) {bo = '+/- feio'} else if (feio == 24 ) {bo = '+/- feio'} else if (feio == 25 ) {bo = '+/- feio'} else if (feio == 26 ) {bo = '+/- feio'} else if (feio == 27 ) {bo = '+/- feio'} else if (feio == 2 ) {bo = '+/- feio'} else if (feio == 29 ) {bo = '+/- feio'} else if (feio == 30 ) {bo = '+/- feio'} else if (feio == 31 ) {bo = 'Ainda tÃ¡ na mÃ©dia'} else if (feio == 32 ) {bo = 'Da pra pegar umas(ns) novinha(o) ainda'} else if (feio == 33 ) {bo = 'Da pra pegar umas(ns) novinha(o) ainda'} else if (feio == 34 ) {bo = 'Ã‰ fein, mas tem baum coraÃ§Ã£o'} else if (feio == 35 ) {bo = 'TÃ¡ na mÃ©dia, mas nÃ£o deixa de ser feii'} else if (feio == 36 ) {bo = 'Bonitin mas Ã© feio com orgulho'} else if (feio == 37 ) {bo = 'Feio e preguiÃ§oso(a), vai se arrumar praga feia'} else if (feio == 3 ) {bo = 'tenho '} else if (feio == 39 ) {bo = 'Feio, mas um banho E se arrumar, deve resolver'} else if (feio == 40 ) {bo = 'FeiN,  mas nÃ£o existe gente feia, existe gente que nÃ£o conhece os produtos jequity'} else if (feio == 41 ) {bo = 'vocÃª Ã© Feio, mas Ã© legal, continue assim'} else if (feio == 42 ) {bo = 'Nada que uma maquiagem e se arrumar, que nÃ£o resolva ğŸ¥´'} else if (feio == 43 ) {bo = 'Feio que dÃ³i de ver, compra uma mÃ¡scara que melhora'} else if (feio == 44 ) {bo = 'Feio mas nada que um saco na cabeÃ§a nÃ£o resolva nÃ©!?'} else if (feio == 45 ) {bo = 'vocÃª Ã© feio, mas tem bom gosto'} else if (feio == 46 ) {bo = 'Feio mas tem muitos amigos'} else if (feio == 47 ) {bo = 'Feio mas tem lÃ¡bia pra pegar vÃ¡rias novinha'} else if (feio == 4 ) {bo = 'Feio e ainda nÃ£o sabe se vestir, vixi'} else if (feio == 49 ) {bo = 'Feiooo'} else if (feio == 50 ) {bo = 'vocÃª Ã© Feio, mas nÃ£o se encherga ğŸ§'} else if (feio > 51) {bo = 'vocÃª Ã© Feio demais ğŸ™ˆ'} 

await conn.sendMessage(from, {image: wew, caption: '  O quanto vocÃª Ã© feio? \n\n ã€Œ '+rate+' ã€VocÃª Ã©: â° '+random+'% â± feio\n\n '+bo+' '}, {quoted: info})
 }, 7000)
break 

case 'matar':
case 'mata':  
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('marque o alvo que vocÃª quer matar')
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
susp = `VocÃª Acabou de matar o(a) @${mentioned[0].split('@')[0]} ğŸ˜ˆğŸ‘¹` 
jrpp = await getBuffer(`${matarcmd}`)
await conn.sendMessage(from, {video: jrpp, gifPlayback: true, caption: susp}, {quoted: info})
break 

case 'corno':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
rate = body.slice(7)
reply(' â° Pesquisando a ficha de corno : '+rate+', aguarde... â±')
 setTimeout(async() => {
wew = await getBuffer(`${imgcorno}`)
zxzz = 
random = `${Math.floor(Math.random() * 110)}`
await conn.sendMessage(from, {image: wew, caption: '  O quanto vocÃª Ã© corno? \n\n ã€Œ '+rate+' ã€VocÃª Ã©: â° '+random+'% â±  corno ğŸƒ'}, { quoted: info})
}, 7000)
break

case 'vesgo':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
rate = body.slice(7)
reply(' â° Pesquisando a ficha de vesgo : '+rate+', aguarde... â±')
 setTimeout(async() => {
wew = await getBuffer(`${imgvesgo}`)
zxzz = 
random = `${Math.floor(Math.random() * 110)}`
await conn.sendMessage(from, {image: wew, caption: 'O quanto vocÃª Ã© vesgo? \n\nã€Œ '+rate+' ã€VocÃª Ã©: â° '+random+'% â±  Vesgo ğŸ™„ğŸ˜†'}, {quoted: info})
}, 7000)
break 

case 'bebado':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
rate = body.slice(7)
reply(' â° Pesquisando a ficha de bebado : '+rate+', aguarde... â±')
 setTimeout(async() => {
wew = await getBuffer(`${imgbebado}`)
zxzz = 
random = `${Math.floor(Math.random() * 110)}`
await conn.sendMessage(from, {image: wew, caption: 'O quanto vocÃª Ã© bebado? \n\nã€Œ '+rate+' ã€VocÃª Ã©: â° '+random+'% â± BÃªbado ğŸ¤¢ğŸ¥µğŸ¥´'}, {quoted: info})
}, 7000)
break 

case 'gado':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
rate = body.slice(6)
reply(' â° Pesquisando a ficha de gado : '+rate+', aguarde... â±')
 setTimeout(async() => {
wew = await getBuffer(`${imggado}`)
zxzz = 
random = `${Math.floor(Math.random() * 110)}`
await conn.sendMessage(from, {image: wew, caption: 'O quanto vocÃª Ã© gado? \n\nã€Œ '+rate+' ã€VocÃª Ã©: â° '+random+'% â±  gado ğŸ‚'}, {quoted: info})
}, 7000)
break 

case 'gostoso':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
rate = body.slice(9)
reply(' â° Pesquisando a sua ficha de gostoso : '+rate+' aguarde... â±')
 setTimeout(async() => {
wew = await getBuffer(`${imggostoso}`)
zxzz = 
random = `${Math.floor(Math.random() * 110)}`
await conn.sendMessage(from, {image: wew, caption: '  O quanto vocÃª Ã© gostoso? ğŸ˜\n\nã€Œ '+rate+' ã€VocÃª Ã©: â° '+random+'% â± gostoso ğŸ˜', gifPlayback: true}, {quoted: info})
}, 7000)
break 

case 'gostosa':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
rate = body.slice(9)
reply(' â° Pesquisando a sua ficha de gostosa : '+rate+' aguarde... â±')
 setTimeout(async() => {
wew = await getBuffer(`${imggostosa}`)
zxzz = 
random = `${Math.floor(Math.random() * 110)}`
await conn.sendMessage(from, {image: wew, caption: 'O quanto vocÃª Ã© gostosa? ğŸ˜\n\nã€Œ '+rate+' ã€VocÃª Ã©: â° '+random+'% â±  gostosa ğŸ˜³'}, {quoted: info})
}, 7000)
break

case 'beijo':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque alguÃ©m que vc quer da um beijo')
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
susp = `VocÃª deu um beijo gostoso na(o) @${mentioned[0].split('@')[0]} ğŸ˜ğŸ‘‰ğŸ‘ˆâ¤` 
wew = await getBuffer(`${beijocmd}`)
await conn.sendMessage(from, {video: wew, gifPlayback: true, caption: susp}, {quoted: info})
break

case 'tapa':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for, apenas digite ${prefix}modobrincadeira 1`)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('marque o alvo que vocÃª quer dÃ¡ o tapa')
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
susp = `VocÃª Acabou de da um tapa na raba dağŸ˜ @${mentioned[0].split('@')[0]} ğŸ”¥` 
jrq = await getBuffer(`${tapacmd}`)
await conn.sendMessage(from, {video: jrq, gifPlayback: true, caption: susp}, {quoted: info})
break

case 'chute':
case 'chutar':  
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('marque o alvo que vocÃª quer dÃ¡ um chute')
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
susp = `VocÃª Acabou de da um chute em @${mentioned[0].split('@')[0]} ğŸ¤¡` 
jry = await getBuffer(`${chutecmd}`)
await conn.sendMessage(from, {video: jry, gifPlayback: true, caption: susp}, {quoted: info})
break 

case 'dogolpe':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
if (args.length < 1) return await conn.sendMessage(from, {text: 'coloca um nome'}, {quoted: info})
pkt = body.slice(9)
random = `${Math.floor(Math.random() * 100)}`
jpr = `*GOLPISTA ENCONTRADOğŸ‘‰ğŸ»*\n\n*GOLPISTA* : *${args[0]}*\n*PORCENTAGEM DO GOLPE* : ${random}%ğŸ˜‚\n\nEle(a) gosta de ferir sentimentos ğŸ˜¢`
reply(jpr)
break

case 'shipo':
teks = args.join(" ")
if(teks.length < 10) return reply('Marque uma pessoa do grupo para encontrar o par dela')
membrr = []
const suamae111 = groupMembers
const suamae211 = groupMembers
const teupai111 = suamae111[Math.floor(Math.random() * suamae111.length)]
const teupai211 = suamae211[Math.floor(Math.random() * suamae211.length)]
var shipted1 = ["1%", `2%`, `3%`, `4%`, `5%`, `6%`, `7`, `%`, `9%`, `10`, `11%`, `12%`,`13%`, `14%`, `15%`, `16%`, `17%`, `1%`, `19%`, `20%`, `21%`, `22`, `23%`, `24%`, `25%`, `26%`, `27%`, `2%`, `27%`, `2%`, `29%`, `30%`, `31%`, `32%`, `33%`, `34%`, `35%`, `36%`, `37%`, `3%`, `39%`, `40%`, `41%`, `42%`, `43%`, `44%`, `45%`, `46%`, `47%`, `4%`, `49%`, `50%`, `51%`, `52%`, `53%`, `54%`, `55%`, `56%`, `57%`, `5%`, `59%`, `60%`, `61%`, `62%`, `63%`, `64%`, `65%`, `66%`, `67%`, `6%`, `69%`, `70%`, `71%`, `72%`, `73%`, `74%`, `75%`, `76%`, `77%`, `7%`, `79%`, `0%`, `1%`, `2%`, `5%`, `4%`, `5%`, `6%`, `7%`, `%`, `9%`, `90%`, `91%`, `92%`, `93%`, `94%`, `95%`, `96%`, `97%`, `9%`, `99%`, `100%`]
const shiptedd = shipted1[Math.floor(Math.random() * shipted1.length)]
jet = `*Hmmm.... Eu Shipo eles 2ğŸ’˜ğŸ’˜*\n\n1 = @${teupai111.id.split('@')[0]}\n && 2 = ${teks} com uma porcentagem de: ${shiptedd}`
membrr.push(teupai111.id)
membrr.push(teupai211.id)
mentions(jet, membrr, true)
break

case 'casal':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
membr = []
const suamae11 = groupMembers
const suamae21 = groupMembers
const teupai11 = suamae11[Math.floor(Math.random() * suamae11.length)]
const teupai21 = suamae21[Math.floor(Math.random() * suamae21.length)]
var shipted1 = ["1%", `2%`, `3%`, `4%`, `5%`, `6%`, `7`, `%`, `9%`, `10`, `11%`, `12%`,`13%`, `14%`, `15%`, `16%`, `17%`, `1%`, `19%`, `20%`, `21%`, `22`, `23%`, `24%`, `25%`, `26%`, `27%`, `2%`, `27%`, `2%`, `29%`, `30%`, `31%`, `32%`, `33%`, `34%`, `35%`, `36%`, `37%`, `3%`, `39%`, `40%`, `41%`, `42%`, `43%`, `44%`, `45%`, `46%`, `47%`, `4%`, `49%`, `50%`, `51%`, `52%`, `53%`, `54%`, `55%`, `56%`, `57%`, `5%`, `59%`, `60%`, `61%`, `62%`, `63%`, `64%`, `65%`, `66%`, `67%`, `6%`, `69%`, `70%`, `71%`, `72%`, `73%`, `74%`, `75%`, `76%`, `77%`, `7%`, `79%`, `0%`, `1%`, `2%`, `5%`, `4%`, `5%`, `6%`, `7%`, `%`, `9%`, `90%`, `91%`, `92%`, `93%`, `94%`, `95%`, `96%`, `97%`, `9%`, `99%`, `100%`]
const shipted = shipted1[Math.floor(Math.random() * shipted1.length)]
jet = `*Hmmm.... Eu Shipo eles 2ğŸ’˜ğŸ’˜*\n\n1= @${teupai11.id.split('@')[0]}\ne esse\n2= @${teupai21.id.split('@')[0]}\ncom uma porcentagem de: ${shipted}`
membr.push(teupai11.id)
membr.push(teupai21.id)
mentions(jet, membr, true)
break

case 'nazista':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
rate = body.slice(9)
reply(' â° Pesquisando a sua ficha de nazista : '+rate+' aguarde... â±')
 setTimeout(async() => {
wew = await getBuffer(`${imgnazista}`)
zxzz = 
random = `${Math.floor(Math.random() * 110)}`
await conn.sendMessage(from, {image: wew, caption: 'O quanto vocÃª Ã© nazista? \n\nã€Œ '+rate+' ã€VocÃª Ã©: â° '+random+'% â±  nazista å'}, {quoted: info})
}, 7000)
break 

case 'rankativo':
case 'rankativos':  
if (!isGroup) return reply(enviar.msg.grupo)
if(groupIdscount.indexOf(from) < 0) return reply('O bot nÃ£o tem ainda dados sobre o grupo')
var ind = groupIdscount.indexOf(from)
if(countMessage[ind].numbers.length < 3) return reply('Necessita do registro de 3 usuarios')
countMessage[ind].numbers.sort((a, b) => (a.messages < b.messages) ? 1 : -1)
mentioned_jid = []
boardi = 'ğŸ”¥áâƒŸÂ Â Â  Ranking dos membros mais ativos:\n\n'
try {
for (let i = 0; i < 5; i++) {
if (i == 0) boardi += `${i + 1}Âº ğŸ¥‡ : @${countMessage[ind].numbers[i].id.split('@')[0]}\nMensagens: ${countMessage[ind].numbers[i].messages}\nComandos dados: ${countMessage[ind].numbers[i].cmd_messages}\n\n`
else if (i == 1) boardi += `${i + 1}Âº ğŸ¥ˆ : @${countMessage[ind].numbers[i].id.split('@')[0]}\nMensagens: ${countMessage[ind].numbers[i].messages}\nComandos dados: ${countMessage[ind].numbers[i].cmd_messages}\n\n`
else if (i == 2) boardi += `${i + 1}Âº ğŸ¥‰ : @${countMessage[ind].numbers[i].id.split('@')[0]}\nMensagens: ${countMessage[ind].numbers[i].messages}\nComandos dados: ${countMessage[ind].numbers[i].cmd_messages}\n\n`
else if (i == 3) boardi += `${i + 1}Âº ğŸ¥‰ : @${countMessage[ind].numbers[i].id.split('@')[0]}\nMensagens: ${countMessage[ind].numbers[i].messages}\nComandos dados: ${countMessage[ind].numbers[i].cmd_messages}\n\n`	
else if (i == 4) boardi += `${i + 1}Âº ğŸ¥‰ : @${countMessage[ind].numbers[i].id.split('@')[0]}\nMensagens: ${countMessage[ind].numbers[i].messages}\nComandos dados: ${countMessage[ind].numbers[i].cmd_messages}\n\n`			
				
mentioned_jid.push(countMessage[ind].numbers[i].id)
} 
mentions(boardi, mentioned_jid, true)
} catch (err) {
			console.log(err)
await conn.sendMessage(from, {text: `Ã‰ necessÃ¡rio 5 jogadores para se construir um ranking`}, {quoted: info})
}
break

case 'checkativo':
if (!isGroup) return reply(enviar.msg.grupo)
if(groupIdscount.indexOf(from) < 0) return reply('O bot nÃ£o tem ainda dados sobre o grupo')
var ind = groupIdscount.indexOf(from)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque o nÃºmero que deseja puxar a atividade')
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
if(numbersIds.indexOf(mentioned[0]) >= 0) {
var indnum = numbersIds.indexOf(mentioned[0])
mentions(`ğ–£˜âƒŸá—’ Consulta das atividade de\nğ–£˜âƒŸá—’ @${mentioned[0].split('@')[0]} no grupo\nğ–£˜âƒŸá—’ Mensagens: ${countMessage[ind].numbers[indnum].messages}\nğ–£˜âƒŸá—’ Comandos dados: ${countMessage[ind].numbers[indnum].cmd_messages}`, mentioned, true)
}
else {
mentions(`â‹†âƒŸÛœÛ£á­ªâ£ Consulta da atividade de â‹†âƒŸÛœÛ£á­ªâ£ @${mentioned[0].split('@')[0]} no grupo\nâ‹†âƒŸÛœÛ£á­ªâ£ Mensagens: 0\nâ‹†âƒŸÛœÛ£á­ªâ£ Comandos dados: 0`, mentioned, true)
}
break

case 'ranklevel':
case 'rl':
case 'rank':
_level.sort((a, b) => (a.xp < b.xp) ? 1 : -1)
let leaderboardlvl = '    ğŸ†ã€Š Rank Niveis ã€‹ğŸ†\n\n'
let nom = 0
try {
for (let i = 0; i < 10; i++) {
nom++
leaderboardlvl += `
â” âœ˜ğŸŒ– ${setting.NomeDoBot} ğŸŒ˜âœ˜â”“
â”ƒâ€¢â”€â”€â”€â”€â€¢â”€â”€â”€â”€â”€â”€â”€â€¢â”€â”€â”€â€¢
â”£â²ğŸ†â³ [${nom}] ÏŸâ  ${_level[i].id.replace('@s.whatsapp.net', '')}
â”£â²ğŸ†â³ã€Œxpã€: ÏŸ${_level[i].xp}
â”£â²ğŸ†â³ã€ŒLevelã€ :ÏŸâ  ${_level[i].level}
â”— â”€â”€â”€â”€â”€â”€ã€Œâ˜…ã€â”€â”€â”€â”€â”€â”€â”š\n`

}
leaderboardlvl += `Ã—â€¢-â€¢-â€¢âŸ® ğŸ†Ranking LevelğŸ†âŸ¯â€¢-â€¢-â€¢Ã—`
if(verificado === true) {
conn.sendMessage(from, {text: leaderboardlvl, sendEphemeral: true}, {quoted: selo})
} else {
conn.sendMessage(from, {text: leaderboardlvl, sendEphemeral: true}, {quoted: info})
}
} catch (err) {
console.error(err)
await reply(`Deve conter 10 pessoas com level, e o leveling deve estÃ¡ ativado para que aconteÃ§a a evoluÃ§Ã£o de level dos membros, apÃ³s as interaÃ§Ãµes`)
}
break

case 'rankgay':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
try{
d = []
ret = 'ğŸ³ï¸â€ğŸŒˆ Rank dos mais gays\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
ret += `ğŸ³ï¸â€ğŸŒˆâ§ @${groupMembers[r].id.split('@')[0]}\n`
d.push(groupMembers[r].id)
}
mentions(ret, d, true)
} catch (e) {
console.log(e)
reply('Deu erro, tente novamente :/')
}
break

case 'rankgado':
case 'rankgados':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
try{
d = []
ret = 'ğŸ‚ğŸ‚ Rank dos mais gados do grupo \n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
ret += `ğŸ‚â§ @${groupMembers[r].id.split('@')[0]}\n`
d.push(groupMembers[r].id)
}
mentions(ret, d, true)
} catch (e) {
console.log(e)
reply('Deu erro, tente novamente :/')
}
break

case 'rankcorno':
case 'rankcornos':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
membr = []
const corno1 = groupMembers
const corno2 = groupMembers
const corno3 = groupMembers
const corno4 = groupMembers
const corno5 = groupMembers
const cornos1 = corno1[Math.floor(Math.random() * corno1.length)]
const cornos2 = corno2[Math.floor(Math.random() * corno2.length)]
const cornos3 = corno3[Math.floor(Math.random() * corno3.length)]
const cornos4 = corno4[Math.floor(Math.random() * corno4.length)]
const cornos5 = corno5[Math.floor(Math.random() * corno5.length)]
var porcentagemcorno = ["1%", `2%`, `3%`, `4%`, `5%`, `6%`, `7`, `%`, `9%`, `10`, `11%`, `12%`,`13%`, `14%`, `15%`, `16%`, `17%`, `1%`, `19%`, `20%`, `21%`, `22`, `23%`, `24%`, `25%`, `26%`, `27%`, `2%`, `27%`, `2%`, `29%`, `30%`, `31%`, `32%`, `33%`, `34%`, `35%`, `36%`, `37%`, `3%`, `39%`, `40%`, `41%`, `42%`, `43%`, `44%`, `45%`, `46%`, `47%`, `4%`, `49%`, `50%`, `51%`, `52%`, `53%`, `54%`, `55%`, `56%`, `57%`, `5%`, `59%`, `60%`, `61%`, `62%`, `63%`, `64%`, `65%`, `66%`, `67%`, `6%`, `69%`, `70%`, `71%`, `72%`, `73%`, `74%`, `75%`, `76%`, `77%`, `7%`, `79%`, `0%`, `1%`, `2%`, `5%`, `4%`, `5%`, `6%`, `7%`, `%`, `9%`, `90%`, `91%`, `92%`, `93%`, `94%`, `95%`, `96%`, `97%`, `9%`, `99%`, `O chifre desse ai bate na lua ksksksk`]
const porcentagemc = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porcentag = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porcent = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porcl = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porg = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const prg = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
ytb = `
Esses sÃ£o os cornos do grupo ${groupName}\n@${cornos1.id.split('@')[0]}\nCom uma porcentagem de ${porcent}\n@${cornos2.id.split('@')[0]}\nCom uma porcentagem de ${porcentag}\n@${cornos3.id.split('@')[0]}\nCom uma porcentagem de ${porcl}\n@${cornos4.id.split('@')[0]}\nCom uma porcentagem de ${porg}\n@${cornos5.id.split('@')[0]}\nCom uma porcentagem de ${prg}\n\nâš¡ ${setting.NomeDoBot} âš¡`
membr.push(cornos1.id)
membr.push(cornos2.id)
membr.push(cornos3.id)
membr.push(cornos4.id)
membr.push(cornos5.id)
mentions(ytb, membr, true)
break

case 'rankgostosos':
case 'rankgostoso':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
member = []
const p01 = groupMembers
const p02 = groupMembers
const p03 = groupMembers
const p04 = groupMembers
const p05 = groupMembers
const o01 = p01[Math.floor(Math.random() * p01.length)]
const o02 = p02[Math.floor(Math.random() * p02.length)]
const o03 = p03[Math.floor(Math.random() * p03.length)]
const o04 = p04[Math.floor(Math.random() * p04.length)]
const o05 = p05[Math.floor(Math.random() * p05.length)]
luy = `
Parados!ğŸ¤šğŸ¤š\n\n1=ğŸ¤šğŸ¤­@${o01.id.split('@')[0]}ğŸ¤šğŸ¤­\n\n\n2=ğŸ¤šğŸ¤­@${o02.id.split('@')[0]}ğŸ¤šğŸ¤­\n\n\n3=ğŸ¤šğŸ¤­@${o03.id.split('@')[0]}ğŸ¤šğŸ¤­\n\n\n4=ğŸ¤šğŸ¤­@${o04.id.split('@')[0]}ğŸ¤šğŸ¤­\n\n\n5=ğŸ¤šğŸ¤­@${o05.id.split('@')[0]}ğŸ¤šğŸ¤­\n\n\nMulta por serem gostosos dmsğŸ˜³ pague pena trabalhando em nossa agÃªncia de modelos ğŸ˜Š by: ${NomeDoBot}`
member.push(o01.id)
member.push(o02.id)
member.push(o03.id)
member.push(o04.id)
member.push(o05.id)
mentions(luy, member, true)
break

case 'rankgostosas':
case 'rankgostosa':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
member = []
const p1 = groupMembers
const p2 = groupMembers
const p3 = groupMembers
const p4 = groupMembers
const p5 = groupMembers
const o1 = p1[Math.floor(Math.random() * p1.length)]
const o2 = p2[Math.floor(Math.random() * p2.length)]
const o3 = p3[Math.floor(Math.random() * p3.length)]
const o4 = p4[Math.floor(Math.random() * p4.length)]
const o5 = p5[Math.floor(Math.random() * p5.length)]
luy = `
Paradas!ğŸ¤šğŸ¤š\n\n1=ğŸ¤šğŸ¤­@${o1.id.split('@')[0]}ğŸ¤šğŸ¤­\n\n\n2=ğŸ¤šğŸ¤­@${o2.id.split('@')[0]}ğŸ¤šğŸ¤­\n\n\n3=ğŸ¤šğŸ¤­@${o3.id.split('@')[0]}ğŸ¤šğŸ¤­\n\n\n4=ğŸ¤šğŸ¤­@${o4.id.split('@')[0]}ğŸ¤šğŸ¤­\n\n\n5=ğŸ¤šğŸ¤­@${o5.id.split('@')[0]}ğŸ¤šğŸ¤­\n\n\nMultas por serem gostosas dmsğŸ˜³ pague pena enviando nud no PV do donoğŸ˜Š by Bot`
member.push(o1.id)
member.push(o2.id)
member.push(o3.id)
member.push(o4.id)
member.push(o5.id)
mentions(luy, member, true)
break

case 'ranknazista':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
try{
if(!isGroup) return reply(enviar.msg.grupo)
d = []
teks = 'ğŸ’‚â€â™‚ï¸Rank dos mais nazistas do gp\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `ğŸ’‚â€â™‚ï¸â§ @${groupMembers[r].id.split('@')[0]}\n`
d.push(groupMembers[r].id)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro, tente novamente :/')
}
break

case 'rankotakus':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
membr = []
const otaku1 = groupMembers
const otaku2 = groupMembers
const otaku3 = groupMembers
const otaku4 = groupMembers
const otaku5 = groupMembers
const otaku6 = groupMembers
const otaku7 = groupMembers
const otaku = groupMembers
const otaku9 = groupMembers
const otaku10 = groupMembers
const otakus1 = otaku1[Math.floor(Math.random() * otaku1.length)]
const otakus2 = otaku2[Math.floor(Math.random() * otaku2.length)]
const otakus3 = otaku3[Math.floor(Math.random() * otaku3.length)]
const otakus4 = otaku4[Math.floor(Math.random() * otaku4.length)]
const otakus5 = otaku5[Math.floor(Math.random() * otaku5.length)]
const otakus6 = otaku6[Math.floor(Math.random() * otaku6.length)]
const otakus7 = otaku7[Math.floor(Math.random() * otaku7.length)]
const otakus = otaku[Math.floor(Math.random() * otaku.length)]
const otakus9 = otaku9[Math.floor(Math.random() * otaku9.length)]
const otakus10 = otaku10[Math.floor(Math.random() * otaku10.length)]
ytb = `esses sÃ£o os otakus fedidos do grupo\n@${otakus1.id.split('@')[0]}\n@${otakus2.id.split('@')[0]}\n@${otakus3.id.split('@')[0]}\n@${otakus4.id.split('@')[0]}\n@${otakus5.id.split('@')[0]}\n@${otakus6.id.split('@')[0]}\n@${otakus7.id.split('@')[0]}\n@${otakus.id.split('@')[0]}\n@${otakus9.id.split('@')[0]}\n@${otakus10.id.split('@')[0]}\n\nâš¡ ${setting.NomeDoBot} âš¡`
membr.push(otakus1.id)
membr.push(otakus2.id)
membr.push(otakus3.id)
membr.push(otakus4.id)
membr.push(otakus5.id)
membr.push(otakus6.id)
membr.push(otakus7.id)
membr.push(otakus.id)
membr.push(otakus9.id)
membr.push(otakus10.id)
mentions(ytb, membr, true)
break

case 'rankpau':
if(!isGroup) return reply('SÃ³ pode ser utilizado este comando, em grupo.')
if(!isModobn) return reply(`Este tipo de comando sÃ³ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se vocÃª for um, apenas digite ${prefix}modobrincadeira 1`)
membr = []
const pauz1 = groupMembers
const pauz2 = groupMembers
const pauz3 = groupMembers
const pauz4 = groupMembers
const pauz5 = groupMembers
const paus1 = pauz1[Math.floor(Math.random() * pauz1.length)]
const paus2 = pauz2[Math.floor(Math.random() * pauz2.length)]
const paus3 = pauz3[Math.floor(Math.random() * pauz3.length)]
const paus4 = pauz4[Math.floor(Math.random() * pauz4.length)]
const paus5 = pauz5[Math.floor(Math.random() * pauz5.length)]
var pcpau1 = ["MinuscÃºlo", `Pequenino`, `Pequeno`, `MÃ©dio`, `Grandinho`, `Grande`, `GrandÃ£o`, `Gigante`, `Gigantesco`, `Enorme`, `BATENDO NA LUA`, `QUEIMADO, TÃƒO GRANDE QUE BATEU NO SOL E QUEIMOU ksksksk`]
var pcpau2 = ["MinuscÃºlo", `Pequenino`, `Pequeno`, `MÃ©dio`, `Grandinho`, `Grande`, `GrandÃ£o`, `Gigante`, `Gigantesco`, `Enorme`, `BATENDO NA LUA`, `QUEIMADO, TÃƒO GRANDE QUE BATEU NO SOL E QUEIMOU ksksksk`]
var pcpau3 = ["MinuscÃºlo", `Pequenino`, `Pequeno`, `MÃ©dio`, `Grandinho`, `Grande`, `GrandÃ£o`, `Gigante`, `Gigantesco`, `Enorme`, `BATENDO NA LUA`, `QUEIMADO, TÃƒO GRANDE QUE BATEU NO SOL E QUEIMOU ksksksk`]
var pcpau4 = ["MinuscÃºlo", `Pequenino`, `Pequeno`, `MÃ©dio`, `Grandinho`, `Grande`, `GrandÃ£o`, `Gigante`, `Gigantesco`, `Enorme`, `BATENDO NA LUA`, `QUEIMADO, TÃƒO GRANDE QUE BATEU NO SOL E QUEIMOU ksksksk`]
var pcpau5 = ["MinuscÃºlo", `Pequenino`, `Pequeno`, `MÃ©dio`, `Grandinho`, `Grande`, `GrandÃ£o`, `Gigante`, `Gigantesco`, `Enorme`, `BATENDO NA LUA`, `QUEIMADO, TÃƒO GRANDE QUE BATEU NO SOL E QUEIMOU ksksksk`]
const pc1 = pcpau1[Math.floor(Math.random() * pcpau1.length)]
const pc2 = pcpau2[Math.floor(Math.random() * pcpau2.length)]
const pc3 = pcpau3[Math.floor(Math.random() * pcpau3.length)]
const pc4 = pcpau4[Math.floor(Math.random() * pcpau4.length)]
const pc5 = pcpau5[Math.floor(Math.random() * pcpau5.length)]
pdr = `Esses sÃ£o os caras com o menor e maior pau do Grupo\n${groupName}\n\n@${paus1.id.split('@')[0]}\n${pc1}\n@${paus2.id.split('@')[0]}\n${pc2}\n@${paus3.id.split('@')[0]}\n${pc3}\n@${paus4.id.split('@')[0]}\n${pc4}\n@${paus5.id.split('@')[0]}\n${pc5}\n\n ${setting.NomeDoBot}`
membr.push(paus1.id)
membr.push(paus2.id)
membr.push(paus3.id)
membr.push(paus4.id)
membr.push(paus5.id)
mentions(pdr, membr, true)
break 

case 'jogodavelha':
if(!isGroup) return reply('comando apenas para grupos')
joguinhodavelhajs.push(sender)
fs.writeFileSync('./datab/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.push(from)
fs.writeFileSync('./datab/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
if (fs.existsSync(`./armor/tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
const matrix = boardnow._matrix;
const chatMove = `*ğŸ®á€Ì¸áªÌ¸á·Ì¸á¬Ì¸ á Ì¸áªÌ¸ á™Ì¸á¬Ì¸áÌ¸á»Ì¸áªÌ¸ğŸ•¹ï¸*
     
[â—] AlguÃ©m estÃ¡ jogando no momento...\n\n@${boardnow.X} VS @${boardnow.O}
     
âŒ : @${boardnow.X}
â­• : @${boardnow.O}
     
 Sua vez : @${boardnow.turn == "X" ? boardnow.X : boardnow.O}
     
${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}
${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}
${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}
`;
conn.sendMessage(from, {text: chatMove}, {quoted: info,
contextInfo: {
mentionedJid: [
boardnow.X + "@s.whatsapp.net",
boardnow.O + "@s.whatsapp.net",
],
},
});
return;
}
if (argss.length === 1)
return reply(`*âŸ…â—âŸ† Jogue com Alguem!!!!*
*para inicar a partida : ${prefix + command} @membro do gp*`);
const boardnow = setGame(`${from}`);
console.log(`Start No jogodavelha ${boardnow.session}`);
boardnow.status = false;
boardnow.X = sender.replace("@s.whatsapp.net", "");
boardnow.O = argss[1].replace("@", "");
fs.writeFileSync(`./armor/tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
const strChat = `*ã€ğŸ“Œá¬Õá¢á¬á¡áªÎá Ï´ Ï´ Ï´á¢Ï´Îá¬ÎÍ²á¬âš”ï¸ã€*
     
@${sender.replace("@s.whatsapp.net",
"")} _estÃ¡ te desafiando para uma partida de jogo da velha..._
_[ ${argss[1]} ] Use *ã€Sã€* para aceitar ou *ã€Nã€* para nÃ£o aceitar..._
     `;
conn.sendMessage(from, {text: strChat}, {quoted: info,
contextInfo: {
mentionedJid: [sender, argss[1].replace("@", "") + "@s.whatsapp.net"],
},
});
break

case 'resetarvelha':
case 'resetavelha':  
case 'resetarv':
case 'resetav': 
case 'resetvelha':
case 'rv': 
if (!isJoguin && !isGroupAdmins) return reply(`Fale com quem iniciou o jogo, sÃ³ ele pode resetar, ou entÃ£o algum ADM`)
if (fs.existsSync("./armor/tictactoe/db/" + from + ".json")) {
fs.unlinkSync("./armor/tictactoe/db/" + from + ".json");
reply(`Jogo da velha resetado com sucesso nesse grupo!`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./datab/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./datab/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
} else {
reply(`NÃ£o a nenhuma sessÃ£o em andamento...`);
}
break

case "ppt":
if (args.length < 1) return reply(`VocÃª deve digitar ${prefix}ppt pedra, ${prefix}ppt papel ou ${prefix}ppt tesoura`)
ppt = ["pedra", "papel", "tesoura"]
ppy = ppt[Math.floor(Math.random() * ppt.length)]
ppg = Math.floor(Math.random() * 1) + 10
pptb = ppy
if ((pptb == "pedra" && args == "papel") ||
(pptb == "papel" && args == "tesoura") ||
(pptb == "tesoura" && args == "pedra")) {
var vit = "vitoria"
} else if ((pptb == "pedra" && args == "tesoura") ||
(pptb == "papel" && args == "pedra") ||
(pptb == "tesoura" && args == "papel")) {
var vit = "derrota"
} else if ((pptb == "pedra" && args == "pedra") ||
(pptb == "papel" && args == "papel") ||
(pptb == "tesoura" && args == "tesoura")) {
var vit = "empate"
} else if (vit = "undefined") {
return reply(`VocÃª deve digitar ${prefix}ppt pedra, ${prefix}ppt papel ou ${prefix}ppt tesoura`)
}
if (vit == "vitoria") {
var tes = "VitÃ³ria do jogador"
}
if (vit == "derrota") {
var tes = "A vitÃ³ria Ã© do BOT"
}
if (vit == "empate") {
var tes = "O jogo terminou em empate"
}
reply(`${NomeDoBot} jogou: ${pptb}\nO jogador jogou: ${args}\n\n${tes}`)
if (tes == "VitÃ³ria do jogador") {
reply(pph)
}
break

case 'cassino':
 //CASSINO
 const soto = [
'ğŸŠ : ğŸ’ : ğŸ',
'ğŸ’ : ğŸ”” : ğŸŠ',
'ğŸ‡ : ğŸ‡ : ğŸ‡',
'ğŸŠ : ğŸ‹ : ğŸ””',
'ğŸ”” : ğŸ’ : ğŸ',
'ğŸ”” : ğŸ’ : ğŸŠ',
'ğŸŠ : ğŸ‹ : ??',		
'ğŸ : ğŸ’ : ğŸ‹',
'ğŸ : ğŸ : ğŸ',
'ğŸŠ : ğŸ’ : ğŸ’',
'ğŸ”” : ğŸ”” : ğŸ‡',
'ğŸŒ : ğŸ’ : ğŸ””',
'ğŸ : ğŸ”” : ğŸ””',
'ğŸŠ : ğŸ‹ : ğŸ’',
'ğŸ‹ : ğŸ‹ : ğŸŒ',
'ğŸ”” : ğŸ”” : ğŸ‡',
'ğŸ”” : ğŸ : ğŸ‡',
'ğŸ”” : ğŸ”” : ğŸ””',
'ğŸ’ : ğŸ’ : ğŸ’',
'ğŸŒ : ğŸŒ : ğŸŒ'
]		
const somtoy2 = sotoy[Math.floor(Math.random() * sotoy.length)]
if ((somtoy2 == 'ğŸ¥‘ : ğŸ¥‘ : ğŸ¥‘') ||(somtoy2 == 'ğŸ‰ : ğŸ‰ : ğŸ‰') ||(somtoy2 == 'ğŸ“ : ğŸ“ : ğŸ“') ||(somtoy2 == 'ğŸ : ğŸ : ğŸ') ||(somtoy2 == 'ğŸ : ğŸ : ğŸ') ||(somtoy2 == 'ğŸ¥ : ğŸ¥ : ğŸ¥') ||(somtoy2 == 'ğŸ‘ : ğŸ‘ : ğŸ‘') ||(somtoy2 == 'ğŸ¥¥ : ğŸ¥¥ : ğŸ¥¥') ||(somtoy2 == 'ğŸ‹ : ğŸ‹ : ğŸ‹') ||(somtoy2 == 'ğŸ : ğŸ : ğŸ') ||(somtoy2 == 'ğŸŒ : ğŸŒ : ğŸŒ') ||(somtoy2 == 'ğŸ’ : ğŸ’ : ğŸ’') ||(somtoy2 == 'ğŸ”” : ğŸ”” : ğŸ””') ||(somtoy2 == 'ğŸŠ : ğŸŠ : ğŸŠ') ||(somtoy2 == 'ğŸ‡ : ğŸ‡ : ğŸ‡')) {
var VitÃ³ria = "VocÃª ganhou!!!"
} else {
var VitÃ³ria = "VocÃª perdeu..."
}
	const cassino = `
â”â”â”â”â”âªğŸ°â«â”â”â”â”
â”£â–º ${somtoy2}â—„â”›
â”—â”â”â”â”âªğŸ’°â«â”â”â”â”

*${VitÃ³ria}*`
reply(cassino)
if (VitÃ³ria == "VocÃª ganhou!!!") {
reply('ParabÃ©ns')
}
await limitAdd(sender)
break

case 'quizanimais':
if(!isGroup) return reply('Comando apenas para grupos')
const animaisquiz = Math.floor(Math.random() * quizanimais.length)
if(!isGroupAdmins) return reply('Comando apenas para admins')
if(args.length == 0) return reply('use 1 para ativar o jogo \npara desativar use quizanimais 0')
if (args.join(' ') === '1') {
if(fs.existsSync(`./armor/quizanim-${from}.json`)) {
let dataAnagrama2 = JSON.parse(fs.readFileSync(`./armor/quizanim-${from}.json`))
imagemtexto =`                             ã€Œâ“Quizâ“ã€`
wew = await getBuffer(`${dataAnagrama2.foto}`)   
await conn.sendMessage(from, {image: wew, caption: imagemtexto, thumbnail: wew}, {quoted: selo})
} else {
fs.writeFileSync(`./armor/quizanim-${from}.json`, `${JSON.stringify(quizanimais[animaisquiz])}`)
imagemtexto =`                             ã€Œâ“Quizâ“ã€`
wew = await getBuffer(`${dataAnagrama2.foto}`)  
if(verificado === true) {
await conn.sendMessage(from, {image: wew, caption: imagemtexto, thumbnail: wew}, {quoted: selo})
} else {
await conn.sendMessage(from, {wew: image, caption: imagemtexto, thumbnail: wew}, {quoted: info})
}
}
} else if (args.join(' ') ==='0') {
if(!fs.existsSync(`./armor/quizanim-${from}.json`)) return reply('NÃ£o tem como desativar o jogo pÃ´s ele nÃ£o foi ativado')
fs.unlinkSync(`./armor/quizanim-${from}.json`)
reply("Desativado com sucesso")
}
await limitAdd(sender)
break

case 'anagrama':
if(!isGroup) return reply('comando apenas para grupos')
const anaaleatorio = Math.floor(Math.random() * palavrasANA.length)
if(!isGroupAdmins) return reply('comando apenas para admins')
if(args.length == 0) return reply('use 1 para ativar o jogo do anagrama\npara desativar use anagrama 0')
if (args.join(' ') === '1') {
if(fs.existsSync(`./armor/anagrama-${from}.json`)) {
let dataAnagrama2 = JSON.parse(fs.readFileSync(`./armor/anagrama-${from}.json`))
reply(`o jogo jÃ¡ foi iniciado neste grupo:
palavra: ${dataAnagrama2.embaralhada}
dica: ${dataAnagrama2.dica}
`)} else {
fs.writeFileSync(`./armor/anagrama-${from}.json`, `${JSON.stringify(palavrasANA[anaaleatorio])}`)
conn.sendMessage(from, {text: `
â•­â”€â”€â”€â”€â”€â‰½ã€Œ ğŸ‘¾ ANAGRAMA ğŸ‘¾ ã€
â”‚â½ DESCUBRA A PALAVRA
â”‚â½ ANAGRAMA: ${palavrasANA[anaaleatorio].embaralhada}
â”‚â½ DICA: ${palavrasANA[anaaleatorio].dica}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`})
}
} else if (args.join(' ') ==='0') {
if(!fs.existsSync(`./armor/anagrama-${from}.json`)) return reply('nÃ£o tem como desativar o jogo do anagrama pÃ´s ele nÃ£o foi ativado')
fs.unlinkSync(`./armor/anagrama-${from}.json`)
reply("desativado com sucesso")
}
await limitAdd(sender)
break

case 'revelaranime':
case 'revelaanime':  
if (!isGroupAdmins) return reply('somente adms')
let dataAnagrama = JSON.parse(fs.readFileSync(`./armor/quizanime-${from}.json`))
reply (`${dataAnagrama.original}`)
break

case 'revelaranimal':
case 'revelaanimal':  
if (!isGroupAdmins) return reply('somente adms')
let dataAnagramaa = JSON.parse(fs.readFileSync(`./armor/quizanim-${from}.json`))
reply (`${dataAnagramaa.original}`)
break

//=======(FIM-BRINCADEIRAS-JOGOS)========\\



//=(CASE-SIMIH-INTELIGÃŠNCIA-ARTIFICIAL)=\\

case 'simi':
if(isSimi) return reply('Desativado')
sduy = args.join(" ")
data = await fetchJson(`https://api.simsimi.net/v2/?text=${sduy}&lc=pt`, {method: 'get'})
simi = `${data.success}`  
reply(simi)
break

case 'simih':
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isSimi) return reply('O modo Simi estÃ¡ ativo')
samih.push(from)
fs.writeFileSync('./datab/usuarios/simi.json', JSON.stringify(samih))
reply('Ativado com sucesso o modo simi neste grupo ğŸ˜—')
} else if (Number(args[0]) === 0) {
if(!isSimi) return reply('JÃ¡ estÃ¡ Desativado.')
samih.splice(from, 1)
fs.writeFileSync('./datab/usuarios/simi.json', JSON.stringify(samih))
reply('Desativado modo simi com sucesso neste grupo ğŸ˜¡ï¸')
} else {
reply('1 para ativar, 0 para desativar, lerdao vc em KKKKK')
}
break

case 'simih2':
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isSimi2) return reply('O modo Simi estÃ¡ ativo')
samih2.push(from)
fs.writeFileSync('./armor/simi.json', JSON.stringify(samih2))
reply('Ativado com sucesso o modo simi neste grupo ğŸ˜—, Este simih2 ele aprende as respostas e perguntas das pessoas, conforme vai falando, por isso, sÃ³ recomendo utilizar ele no termux, pois no site ou lugar diferente do termux que vocÃª utilizar, ele nÃ£o vai armazenar os dados nescessarios')
} else if (Number(args[0]) === 0) {
if(!isSimi2) return reply('JÃ¡ estÃ¡ Desativado.')
samih2.splice(from, 1)
fs.writeFileSync('./armor/simi.json', JSON.stringify(samih2))
reply('Desativado modo simi com sucesso neste grupo ğŸ˜¡ï¸')
} else {
reply('1 para ativar, 0 para desativar, lerdao vc em KKKKK')
}
break

//========================================\\


//==(AUDIOS/DE-MUSICA/ZOUEIRA/ETC..)===\\

case 'bot':
const soundft = fs.readFileSync('audios/qviado.mp3')
await conn.sendMessage(from, {audio: soundft, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
break

case 'infobot':
const cmdoo = fs.readFileSync('audios/infobot.mp3')
await conn.sendMessage(from, {audio: cmdoo, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
break 

//=======================================\\


//=====(ALTERADOR-DE-AUDIO/VIDEO)=======\\

case 'videocontrario':
case 'reversevid':
if (!isQuotedVideo) return reply('Marque um vÃ­deo')
reply(enviar.espere)
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -vf reverse -af areverse ${ran}`, (err) => {
fs.unlinkSync(media)
if (err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
conn.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: info})
fs.unlinkSync(ran)
})
break 

case 'videolento':
case 'slowvid':  
if (!isQuotedVideo) return reply('Marque um vÃ­deo')
reply(enviar.espere) 
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter_complex "[0:v]setpts=2*PTS[v];[0:a]atempo=0.5[a]" -map "[v]" -map "[a]" ${ran}`, (err) => {
fs.unlinkSync(media)
if (err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
conn.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: info })
fs.unlinkSync(ran)
})
break

case 'videorapido':
case 'fastvid':  
if (!isQuotedVideo) return reply('Marque um vÃ­deo')
reply(enviar.espere)
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter_complex "[0:v]setpts=0.5*PTS[v];[0:a]atempo=2[a]" -map "[v]" -map "[a]" ${ran}`, (err) => {
fs.unlinkSync(media)
if (err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
conn.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: info })
fs.unlinkSync(ran)
})		
break

case 'grave2':
if (!isQuotedAudio) return reply('Marque um Ã¡udio')
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=1.6,asetrate=22100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
conn.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
fs.unlinkSync(ran)
})
break

case 'grave':
if (!isQuotedAudio) return reply('Marque um Ã¡udio')
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
conn.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
fs.unlinkSync(ran)
})
break

case 'adolesc':
case 'vozmenino':  
if (!isQuotedAudio) return reply('Marque um Ã¡udio')
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a atempo=1.06,asetrate=44100*1.25 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
conn.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
fs.unlinkSync(ran)
})
break  

case 'tomp3':
if (!isQuotedVideo) return reply('Marque o video pfv')
reply(enviar.espere)
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane 
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} ${ran}`, (err) => { 
fs.unlinkSync(media)
if (err) return reply('âŒ Falha ao converter vÃ­deo para mp3 âŒ')
buffer = fs.readFileSync(ran)
conn.sendMessage(from, {audio: buffer, mimetype: 'audio/mp4'}, {quoted: info})
fs.unlinkSync(ran)
})
break

case 'bass3':
if (!isQuotedAudio) return reply('Marque um Ã¡udio')
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
conn.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
fs.unlinkSync(ran)
})
break

case 'bass': 
if (!isQuotedAudio) return reply('Marque um Ã¡udio')
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
conn.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
fs.unlinkSync(ran)
})
break

case 'bass2': 
if (!isQuotedAudio) return reply('Marque um Ã¡udio')
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=94:width_type=o:width=2:g=30 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
conn.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
fs.unlinkSync(ran)
})
break

case 'estourar': 
if (!isQuotedAudio) return reply('Marque um Ã¡udio')
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=90:width_type=o:width=2:g=30 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
conn.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
fs.unlinkSync(ran)
})
break

case 'fast':
case 'audiorapido':  
if (!isQuotedAudio) return reply('Marque um Ã¡udio')
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=95100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Erro')
hah = fs.readFileSync(ran)
conn.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
fs.unlinkSync(ran)
})
break

case 'esquilo':
if (!isQuotedAudio) return reply('Marque um Ã¡udio')
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.7,asetrate=65100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
conn.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
fs.unlinkSync(ran)
})
break

case 'audiolento': 
case 'slow':
if (!isQuotedAudio) return reply('Marque um Ã¡udio')
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
conn.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
fs.unlinkSync(ran)
})
break

//=========(FIM-ALTERAR-AUDIO)===========\\


//=======(JOGO-DA-VELHA-COM-MAQUINA)=======\\

case 'tttme':
if (!isGroup) return reply('SÃ“ EM GRUPO')
const checkTTTIdMe = getTTTId(sender)
if (checkTTTIdMe === undefined) addTTTId(sender)
conn.sendMessage(from, {text: tttme(pushname, getTTTwins(sender), getTTTdefeats(sender), getTTTties(sender), getTTTpoints(sender))}, {quoted: info})
break

case 'tttrank':
if (!isGroup) return reply(enviar.msg.grupo)
tictactoe.sort((a, b) => (a.points < b.points) ? 1 : -1)
mentioned_jid = []
let board = '*ğŸ”¥Ranking dos melhores playersğŸ”¥*\n\n'
try {
for (let i = 0; i < 3; i++) {
if (i == 0) {board += `${i + 1}Âº ğŸ¥‡ : @${tictactoe[i].id.split('@')[0]}\nâ»â¥ *Ganhou: ${tictactoe[i].wins}*\nâ»â¥ *Perdeu: ${tictactoe[i].defeats}*\nâ»â¥ *Empates: ${tictactoe[i].ties}*\n*â»â¥ PontuaÃ§Ã£o: ${tictactoe[i].points}*\n\n`

} else if (i == 1) {board += `${i + 1}Âº ğŸ¥ˆ : @${tictactoe[i].id.split('@')[0]}\nâ»â¥ *Ganhou: ${tictactoe[i].wins}*\nâ»â¥ *Perdeu: ${tictactoe[i].defeats}*\nâ»â¥ *Empates: ${tictactoe[i].ties}*\n*â»â¥ PontuaÃ§Ã£o: ${tictactoe[i].points}*\n\n`
  
} else if (i == 2) {board += `${i + 1}Âº ğŸ¥‰ : @${tictactoe[i].id.split('@')[0]}\nâ»â¥ *Ganhou: ${tictactoe[i].wins}*\nâ»â¥ *Perdeu: ${tictactoe[i].defeats}*\nâ»â¥ *Empates: ${tictactoe[i].ties}*\n*â»â¥ PontuaÃ§Ã£o: ${tictactoe[i].points}*\n\n`
  
}
mentioned_jid.push(tictactoe[i].id)
} 
mentions(board, mentioned_jid, true)
} catch (err) {
console.log(err)
await conn.sendMessage(from, {text: `*Ã‰ necessÃ¡rio 3 jogadores para se construir um ranking*`}, {quoted: info})
}
break

case 'jogar':
tttset.playertest = sender
if (!isGroup) {
reply(ptbr.group())
} else if (tttset.tttstatus == "off") {
reply(`*O jogo nÃ£o foi iniciado*\n*Digite ${prefix}ttt <dificukdade> para iniciar*`)
} else if (tttset.player != tttset.playertest) {
reply(`*O jogo jÃ¡ foi iniciado por outro player, aguarde ele terminar...*`)
  
} else if (tttset.tttantibug == "on") {
reply(`Aguarde a aÃ§Ã£o anterior ser concluÃ­da...`)

} else {
tttset.tttantibug = "on"
const coordX = args
if (coordX != 'a1' && coordX != 'a2' && coordX != 'a3' &&
coordX != 'b1' && coordX != 'b2' && coordX != 'b3' && coordX != 'c1' && coordX != 'c2' && coordX != 'c3') {
reply(`*Diga a cordenada*\nExemplo: ${prefix}coord a1`)
tttset.tttantibug = "off"
} else {
  
switch (args[0]) {
  
case 'a1':
if (esp.a1 != "ğŸ”²") {
reply('*Esse espaÃ§o ja foi marcado, tente outro')
} else {
esp.a1 = "âŒ"
while (tttset.reActivate1 == "on") {
IA()
}
}
break

case 'a2':
if (esp.a2 != "ğŸ”²") {
reply('*Esse espaÃ§o ja foi marcado, tente outro')
} else {
esp.a2 = "âŒ"
while (tttset.reActivate1 == "on") {
IA()
}
}
break

case 'a3':
if (esp.a3 != "ğŸ”²") {
reply('*Esse espaÃ§o ja foi marcado, tente outro')
} else {
esp.a3 = "âŒ"
while (tttset.reActivate1 == "on") {
IA()
}
}
break

case 'b1':
if (esp.b1 != "ğŸ”²") {
reply('*Esse espaÃ§o ja foi marcado, tente outro')
} else {
esp.b1 = "âŒ"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
                
case 'b2':
if (esp.b2 != "ğŸ”²") {
reply('*Esse espaÃ§o ja foi marcado, tente outro')
} else {
esp.b2 = "âŒ"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
                
case 'b3':
if (esp.b3 != "ğŸ”²") {
reply('*Esse espaÃ§o ja foi marcado, tente outro')
} else {
esp.b3 = "âŒ"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
                
case 'c1':
if (esp.c1 != "ğŸ”²") {
 reply('*Esse espaÃ§o ja foi marcado, tente outro')
} else {
esp.c1 = "âŒ"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
                
case 'c2':
if (esp.c2 != "ğŸ”²") {
reply('*Esse espaÃ§o ja foi marcado, tente outro')
} else {
esp.c2 = "âŒ"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
                
case 'c3':
if (esp.c3 != "ğŸ”²") {
reply('*Esse espaÃ§o ja foi marcado, tente outro')
} else {
esp.c3 = "âŒ"
while (tttset.reActivate1 == "on") {
IA()
}
}
break

}
tttset.reActivate1 = "on"
reply(`ğŸŒ€1ï¸âƒ£2ï¸âƒ£3ï¸âƒ£\nğŸ…°ï¸${esp.a1}${esp.a2}${esp.a3}\nğŸ…±ï¸${esp.b1}${esp.b2}${esp.b3}\nÂ©ï¸${esp.c1}${esp.c2}${esp.c3}`)
var randomTTTXP = 0
            
if (WinnerX()) {
if (isCmd) {
switch (tttset.tttdifficulty) {
              
case "EASY":
randomTTTXP = Math.floor(Math.random() * 25) + 25
addLevelingXp(tttset.player, randomTTTXP)
break

case "NORMAL":
randomTTTXP = Math.floor(Math.random() * 75) + 75
addLevelingXp(tttset.player, randomTTTXP)
break

case "HARD":
randomTTTXP = Math.floor(Math.random() * 200) + 200
addLevelingXp(tttset.player, randomTTTXP)
break
                
case "IMPOSSIBLE":
randomTTTXP = Math.floor(Math.random() * 1000) + 1000
addLevelingXp(tttset.player, randomTTTXP)
break
}
conn.sendMessage(from, {text: `*VOCÃŠ VENCEU, PARABENS*\n\n *VOCÃŠ GANHOU ${randomTTTXP}XP*`})
} else {
conn.sendMessage(from,{text: `*VOCÃŠ VENCEU, PARABENS*`},)
}

const currentTTTwins = getTTTwins(tttset.player)
const checkTTTIdWin = getTTTId(tttset.player)
if (currentTTTwins === undefined && checkTTTIdWin === undefined) addTTTId(tttset.player)
addTTTwin(tttset.player, 1)
addTTTpoints(tttset.player, randomTTTXP)
esp.a1 = "ğŸ”²"; esp.a2 = "ğŸ”²"; esp.a3 = "ğŸ”²"
esp.b1 = "ğŸ”²"; esp.b2 = "ğŸ”²"; esp.b3 = "ğŸ”²"
esp.c1 = "ğŸ”²"; esp.c2 = "ğŸ”²"; esp.c3 = "ğŸ”²"
tttset.tttstatus = "off"
tttset.waitingTime = "on"
} else if (WinnerO()) {
				  
if (isCmd) {
switch (tttset.tttdifficulty) {
case "EASY":
randomTTTXP = 0 - (Math.floor(Math.random() * 200) + 200)
addLevelingXp(tttset.player, randomTTTXP)
break
					
case "NORMAL":
randomTTTXP = 0 - (Math.floor(Math.random() * 75) + 75)
addLevelingXp(tttset.player, randomTTTXP)
break
					
case "HARD":
randomTTTXP = 0 - (Math.floor(Math.random() * 25) + 25)
addLevelingXp(tttset.player, randomTTTXP)
break
					
case "IMPOSSIBLE":
randomTTTXP = 0
addLevelingXp(tttset.player, randomTTTXP)
break

}	
conn.sendMessage(from, {text: `*VocÃª perdeu*\n\n AGORA VC PAGARÃ: ${randomTTTXP}XP`})
	
} else {
conn.sendMessage(from, {text: `*VocÃª perdeu*`})
}
const currentTTTdefeats = getTTTdefeats(tttset.player)
const checkTTTIdDefeat = getTTTId(tttset.player)
if (currentTTTdefeats === undefined && checkTTTIdDefeat === undefined) addTTTId(tttset.player)
addTTTdefeat(tttset.player, 1)
addTTTpoints(tttset.player, randomTTTXP)
esp.a1 = "ğŸ”²"; esp.a2 = "ğŸ”²"; esp.a3 = "ğŸ”²"
esp.b1 = "ğŸ”²"; esp.b2 = "ğŸ”²"; esp.b3 = "ğŸ”²"
esp.c1 = "ğŸ”²"; esp.c2 = "ğŸ”²"; esp.c3 = "ğŸ”²"
tttset.tttstatus = "off"
tttset.waitingTime = "on"
				
} else if (Tie()) {
if (isCmd) {
conn.sendMessage(from, {text: `*JOGO EMPATADO, NÃƒO HOUVE PERDAR*`})
} else {
conn.sendMessage(from, {text: `*JOGO, EMPATADO, TENHA UM BOM DIA*`})
}

const currentTTTties = getTTTties(tttset.player)
const checkTTTIdTie = getTTTId(tttset.player)
if (currentTTTties === undefined && checkTTTIdTie === undefined) addTTTId(tttset.player)
addTTTtie(tttset.player, 1)
esp.a1 = "ğŸ”²"; esp.a2 = "ğŸ”²"; esp.a3 = "ğŸ”²"
esp.b1 = "ğŸ”²"; esp.b2 = "ğŸ”²"; esp.b3 = "ğŸ”²"
esp.c1 = "ğŸ”²"; esp.c2 = "ğŸ”²"; esp.c3 = "ğŸ”²"
tttset.tttstatus = "off"
tttset.waitingTime = "on"
}
tttset.tttantibug = "off"
}
}
break
				
case 'ttt':
const limitrl = getLimit(sender, daily)
if (!isGroup) {
reply(enviar.espere)
} else if (tttset.tttstatus == "on") {
reply(`AlguÃ©m jÃ¡ estÃ¡ jogando no momento\nPor favor aguarde um instante...`)
} else if (tttset.waitingTime == "on") {
reply(`AlguÃ©m jogou recentemente\nPor favor aguarde o tempo de espera...`)
} else if (args == 0 || (args != 'easy' && args != 'Easy' && args != 'EASY' && args != 'normal' && args != 'Normal' && args != 'NORMAL' && args != 'hard' && args != 'Hard' && args != 'HARD'&& args != 'impossible'&& args != 'Impossible' && args != 'IMPOSSIBLE')) {
reply(`Defina a dificuldade\nEx.: ${prefix}ttt easy\n\nDificuldades: easy, normal, hard e impossible`)

} else {
tttset.tttstatus = "on"
tttset.player = sender
tttset.playerName = pushname
tttset.mentionPlayer = info
tttset.local = from
if (args == 'easy' || args == 'Easy' || args == 'EASY') {
tttset.tttdifficulty = "EASY"
} else if (args == 'normal' || args == 'Normal' || args == 'NORMAL') {
tttset.tttdifficulty = "NORMAL"
} else if (args == 'hard' || args == 'Hard' || args == 'HARD') {
tttset.tttdifficulty = "HARD"
} else if (args == 'impossible' || args == 'Impossible' || args == 'IMPOSSIBLE') {
tttset.tttdifficulty = "IMPOSSIBLE"
}
const randomStartIA = Math.floor(Math.random() * 3)
if (randomStartIA == 0) {
IA()
tttset.reActivate1 = "on"	
}
blat =  `ğŸŒ€1ï¸âƒ£2ï¸âƒ£3ï¸âƒ£\nğŸ…°ï¸${esp.a1}${esp.a2}${esp.a3}\nğŸ…±ï¸${esp.b1}${esp.b2}${esp.b3}\nÂ©ï¸${esp.c1}${esp.c2}${esp.c3}`
conn.sendMessage(from, {text: `${blat}\n\nCaso nÃ£o saiba como jogar digite: ${prefix}ttthelp`})
setTimeout( () => {
tttset.waitingTime = "off"
tttset.autoEndTime = "on"
}, 12000) //2 minutos
addLimit(sender, daily)
}
break

case 'ttthelp':
conn.sendMessage(from, {text: ttthelp(prefix)})
break
//==========(EFEITOS-MARCAR)==========\\

case 'triggered':
try {
if(!isQuotedImage) return reply("Marque uma imagem")
if ((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && args.length == 0) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo : info
imagem = await downloadContentFromMessage(boij, 'image')
owgi = Buffer.from([])
for await(const send of imagem) { owgi = Buffer.concat( [ owgi, send ] ) }
res = await upload(owgi)
post = await fetchJson(`https://aleatoryapi.herokuapp.com/canvas/trigger?url=${res}&apikey=${keyale}`)
sendStickerFromUrl(from, {sticker: post}, {quoted:info})
} else {
reply('error')
}
} catch {
reply('ERROR')
}
break

case 'togif':
if (!isQuotedSticker) return reply('*[ â— ] Marque a figurinha animada!*')
if ((isMedia && !info.message.videoMessage || isQuotedSticker) && args.length == 0) {
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
reply('*ã€Œ â— ã€ Aguarde, convertendo a figu em gif...*')
a = await webp_mp4(buff)
mp4 = await getBuffer(a)
conn.sendMessage(from, {video: mp4, gifPlayback: true, filename: `stick.gif`}, {quoted: info})
fs.unlinkSync(buff)
}
break

case 'rename':
case 'roubar':  
if (!isQuotedSticker) return reply('Marque uma figurinha...')
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
var kls = q
var pack = kls.split("/")[0];
var author2 = kls.split("/")[1];
if (!q) return reply('*E o autor e o nome do pacote?*')
if (!pack) return reply(`*por favor escreve o formato certo: ${prefix + command} sad/bla*`)
if (!author2) return reply(`*por favor escreve o formato certo: ${prefix + command} sad/dms*`)
reply(enviar.espere)
bas64 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas64, `${author2}`, `${pack}`)
var sti = new Buffer.from(mantap, 'base64');
conn.sendMessage(from, {sticker: sti, contextInfo: { externalAdReply:{title: `${pack}|${author2}`,body:"", previewType:"PHOTO",thumbnail: sti}}}, {quoted: info})
.catch((err) => {
reply(`â Error, tenta mais tarde`); 
})
break

case 'rip':  
case 'morto':  
try {
if ((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
reply(enviar.espere)
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat( [ base64, send ] ) }
link = await upload(base64)
postt = await getBuffer(`http://aleatoryapi.herokuapp.com/canvas/rip?url=${link}&apikey=${keyale}`)
conn.sendMessage(from, {image: postt}, {quoted: info})
} else {
reply('Selecione uma imagem...!')
}
} catch {
reply('ERROR')
}
break

case 'lgbt':  
try {
if ((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
reply(enviar.espere)
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat( [ base64, send ] ) }
link = await upload(base64)
postt = await getBuffer(`https://aleatoryapi.herokuapp.com/canvas/lgbt?url=${link}&apikey=${keyale}`)
conn.sendMessage(from, {image: postt}, {quoted: info})
} else {
reply('Selecione uma imagem...!')
}
} catch {
reply('ERROR')
}
break

case 'trash':
case 'lixo':  
try {
if ((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat( [ base64, send ] ) }
reply(enviar.espere)
link = await upload(base64)
postt = await getBuffer(`http://aleatoryapi.herokuapp.com/canvas/trash?url=${link}&apikey=${keyale}`)
conn.sendMessage(from, {image: postt}, {quoted: info})
} else {
reply('Selecione uma imagem...!')
}
} catch {
reply('ERROR')
}
break

case 'comporn':
try {
txt = body.slice(9)
jrr = txt.split("/")[0];
jrr1 = txt.split("/")[1];
if(!txt.includes("/")) return reply(`Cade a /\nExemplo: ${prefix + command} Sad/demais`)
reply(enviar.espere)
buffer = await getBuffer(`https://aleatoryapi.herokuapp.com/canvas/phub?nome=${jrr}&msg=${jrr1}&foto=https://telegra.ph/file/954832554bf2b2e40f932.jpg&apikey=${keyale}`)
await conn.sendMessage(from, {image: buffer}, {quoted: info})
} catch {
reply('ERROR')
}
break 

case 'preso':
try {
if ((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
reply(enviar.espere)
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat( [ base64, send ] ) }
link = await upload(base64)
postt = await getBuffer(`https://aleatoryapi.herokuapp.com/canvas/jail?url=${link}&apikey=${keyale}`)
conn.sendMessage(from, {image: postt}, {quoted: info})
} else {
reply('Selecione uma imagem...!')
}
} catch {
reply('ERROR')
}
break

case 'legenda':
try {
gh = args.join(" ")        
txt1 = gh.split('/')[0] || ''
txt2 = gh.split('/')[1] || ''
if(!gh.includes("/")) return reply(`Cade a / mano?\nExemplo: ${prefix + command} Sad/Demais`)  
if ((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedSticker)) {
base64 = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
link = await upload(base64)
postt = await getBuffer(`https://aleatoryapi.herokuapp.com/api/legenda?url=${link}&texto1=${encodeUrl(txt1)}&texto2=${encodeUrl(txt2)}&apikey=${keyale}`) 
conn.sendMessage(from, {image: postt}, {quoted: info})
} else {
reply('Selecione uma imagem...!')
}
} catch {
reply('Error!!')
}
break

case 'zombie':
case 'zumbi':  
try {
if ((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
reply(enviar.espere)
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat( [ base64, send ] ) }
link = await upload(base64)
jrd = await fetchJson(`https://jonaz-api-v2.herokuapp.com/zombie?url=${link}`)
zumb = await getBuffer(jrd.result)
conn.sendMessage(from, {image: zumb}, {quoted: info})
} else {
reply('Selecione uma imagem...!')
}
} catch {
reply('ERROR, DESCULPE.')
}
break

case 'borrar':
case 'figuborrada':
try {
if ((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
reply(enviar.espere)
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat( [ base64, send ] ) }
link = await upload(base64)
postt = await getBuffer(`https://aleatoryapi.herokuapp.com/canvas/blur?url=${link}&apikey=${keyale}`)
conn.sendMessage(from, {image: postt}, {quoted: info})
} else {
reply('Selecione uma imagem...!')
}
} catch {
reply('ERROR')
}
break

case 'hitler':
try {
if ((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
reply(enviar.espere)
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat( [ base64, send ] ) }
link = await upload(base64)
postt = await getBuffer(`http://aleatoryapi.herokuapp.com/canvas/hitler?url=${link}&apikey=${keyale}`)
conn.sendMessage(from, {image: postt}, {quoted: info})
} else {
reply('Selecione uma imagem...!')
}
} catch {
reply('ERROR')
}
break

case 'deletef':
try {
if ((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
reply(enviar.espere)
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat( [ base64, send ] ) }
link = await upload(base64)
postt = await getBuffer(`http://aleatoryapi.herokuapp.com/canvas/delete?url=${link}&apikey=${keyale}`)
conn.sendMessage(from, {image: postt}, {quoted: info})
} else {
reply('Selecione uma imagem...!')
}
} catch {
reply('ERROR')
}
break

case 'wanted':
case 'procurado':
if ((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
reply(enviar.espere)
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat( [ base64, send ] ) }
link = await upload(base64)
postt = await getBuffer(`http://aleatoryapi.herokuapp.com/canvas/procurado?url=${link}&apikey=${keyale}`)
conn.sendMessage(from, {image: postt}, {quoted: info}).catch(e => {
reply("Error!!")  
})
} else {
reply('Selecione uma imagem...!')
}
break

case 'calunia':
k = `${body.slice(10)}`
txt1 = k.split("/")[0];
txt2 = k.split("/")[1];
txt3 = k.split("/")[2];
if(!k.includes("/")) return reply(`Cade a /\nExemplo: ${prefix + command} @marca-a-pessoa/Fala algo como fosse ele/ReaÃ§Ã£o : nossaa..`)
 conn.sendMessage(from, {text: `${txt3}`},{quoted:{    key: {fromMe: false,participant: `${txt1}@s.whatsapp.net`,},message: { "extendedTextMessage": {"text": `${txt2}`,"title": `Hmm`}}}}).catch(e => {
reply("Error!!")  
})
 break

//=======(FIM-EFEITOS-MARCAR)=========\\

default:

//===(CRÃ‰DITOS : ALEATORY CONTEÃšDOS)==\\

if(isBotGroupAdmins && isAntiCtt && type === 'contactMessage') {
if(isGroupAdmins) return conn.sendMessage(from, {text: 'Contato detectado, vocÃª Ã© adm, entÃ£o nÃ£o irei ti remover'}, {quoted: info})
await conn.sendMessage(from, {text: 'opa fechado pelo bot detectado trava contato ou vcard, caso for um engano, fale com algum adm.'}, {quoted: selo})
await conn.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
conn.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await conn.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `ğŸ—‘ï¸\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nğŸ—‘ï¸\nâ²â—â³ *LÉªá´á´˜á´‡á´¢á´€ á´…á´‡ CÊœá´€á´› Cá´É´á´„ÊŸá´œÉªÌá´…á´€* âœ…`
conn.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await conn.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await conn.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await conn.sendMessage(from, { text: 'Aberto nao marque a trava ou levara banâœ…'}, {quoted:selo})
}

if(isBotGroupAdmins && isAntiCtt && type === 'contactsArrayMessage') {
if(isGroupAdmins) return conn.sendMessage(from, {text: 'Contato detectado, vocÃª Ã© adm, entÃ£o nÃ£o irei ti remover'}, {quoted: info})
await conn.sendMessage(from, {text: 'opa fechado pelo bot detectado trava contatos'}, {quoted: selo})
await conn.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
conn.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await conn.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `ğŸ—‘ï¸\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nğŸ—‘ï¸\nâ²â—â³ *LÉªá´á´˜á´‡á´¢á´€ á´…á´‡ CÊœá´€á´› Cá´É´á´„ÊŸá´œÉªÌá´…á´€* âœ…`
conn.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await conn.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await conn.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await conn.sendMessage(from, { text: 'Aberto nao marque a trava ou levara banâœ…'}, {quoted:selo})
}

if(isBotGroupAdmins && Antiloc && type === 'locationMessage') {
if(isGroupAdmins) return conn.sendMessage(from, {text: 'LocalizaÃ§Ã£o detectada, vocÃª Ã© adm, entÃ£o nÃ£o irei ti remover'}, {quoted: info})
await conn.sendMessage(from, {text: 'opa fechado pelo bot, detectado trava LocalizaÃ§Ã£o ou localizaÃ§Ã£o comum, caso for um engano, fale com algum adm.'}, {quoted: selo})
await conn.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
conn.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await conn.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `ğŸ—‘ï¸\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nğŸ—‘ï¸\nâ²â—â³ *LÉªá´á´˜á´‡á´¢á´€ á´…á´‡ CÊœá´€á´› Cá´É´á´„ÊŸá´œÉªÌá´…á´€* âœ…`
conn.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await conn.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await conn.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await conn.sendMessage(from, { text: 'Aberto nao marque a trava ou levara banâœ…'}, {quoted:selo})
}

if(isBotGroupAdmins && isAnticatalogo && type === 'productMessage') {
if(isGroupAdmins) return conn.sendMessage(from, {text: 'Catalogo detectado, vocÃª Ã© adm, entÃ£o nÃ£o irei ti remover'}, {quoted: info})
await conn.sendMessage(from, {text: 'opa fechado pelo bot, detectado trava Catalogo ou Catalogo comum, caso for um engano, fale com algum adm.'}, {quoted: selo})
await conn.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
conn.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await conn.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `ğŸ—‘ï¸\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nğŸ—‘ï¸\nâ²â—â³ *LÉªá´á´˜á´‡á´¢á´€ á´…á´‡ CÊœá´€á´› Cá´É´á´„ÊŸá´œÉªÌá´…á´€* âœ…`
conn.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await conn.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await conn.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await conn.sendMessage(from, { text: 'Aberto nao marque a trava ou levara banâœ…'}, {quoted:selo})
}

if (budy.length >= limitefl) { 
if(!isAntiFlood) return
if(isAntiFlood && isGroupAdmins && isBotGroupAdmins && isPremium) {
if(isBot) return 
reply('*Link detectado, porÃ©m usuÃ¡rio Ã© admin*')
} else {
if(SoDono) return
if(isGroupAdmins) return
if(isPremium) return
var Kic = `${sender.split("@")[0]}@s.whatsapp.net`  
setTimeout( () => {
if(!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe && !isGroupAdmins) return reply('Muitas caracterÃ­sticas enviadas, eu afirmo que pode ser trava, por precauÃ§Ãµes, eu irei remover.')
console.log(color('deram Spam','red'))
}, 100)
setTimeout( () => {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
setTimeout( () => {
}, 0)
}
}

//INICIO DE COMANDOS SEM PREFIXO
switch(testat){
}


if (budy.includes("video do pl") || budy.includes("Video do pl") || budy.includes("Video do PL") || budy.includes("VIDEO DO PL") || budy.includes("PL video") || budy.includes("PL vÃ­deo") || budy.includes("vÃ­deo do pl") || budy.includes("VÃ­deo do PL") || budy.includes("VÃ­deo do Pl")){
anu = await getBuffer('https://telegra.ph/file/0855427ea91c9c74eb290.mp4')
conn.sendMessage(from, {video: anu, mimetype: 'video/mp4'}, {quoted: info})
}

if (budy.includes("bot corno") || (budy.includes("Bot corno"))){
reply("Corno Ã© vocÃª, seu animal")
}

if (budy.includes("adivinha meu celular") || (budy.includes("Adivinha meu celular") || (budy.includes("Adivinha Meu celular") || (budy.includes("Adivinha Meu Celular") || (budy.includes("bot qual meu celular")))) )){
adivinha = info.key.id.length > 21 ? 'Android ğŸ¤£' : info.key.id.substring(0, 2) == '3A' ? 'IOSğŸ˜‚ğŸ˜‚ğŸ˜…' : 'Zap zap web ğŸ˜‚ğŸ˜‚â˜ğŸ¼ğŸ˜…';
await conn.sendMessage(from, {text: adivinha}, {quoted: info})
}

if(messagesC.includes('exec')) {
if(!SoDono  && !isnit && !issupre && !ischyt) return
try{
paramsQuoted = info.message.extendedTextMessage.contextInfo.quotedMessage.conversation || info.message.extendedTextMessage.contextInfo.quotedMessage.extendedTextMessage.text;	
return eval(`${paramsQuoted}`)
console.log(`[EXEC]~> ${paramsQuoted}`)
}catch(e){
reply(e)
}
}

if (messagesC == "corno"){
tujuh = fs.readFileSync('./audios/corno.mp3');
await conn.sendMessage(from, {audio: tujuh, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
}

//==============(ANTILINK)===============\\

switch(ants){
} 

 //=========[--ANTI PALAVRÃƒO --]==========\\
if (isGroup && isPalavrao) { //CREDITOS TIAGO
 if (palavra.includes(budy)) {
 if (!isGroupAdmins) {
 conn.sendMessage(from, {text: `SEM PALAVRÃƒO!! ğŸ˜ !!`}, {quoted : info})       
setTimeout( () => {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 2000)
reply("2")
setTimeout( () => {
reply("1")
}, 1000)
setTimeout( () => {
conn.sendMessage(from, {text: `*ã€Œ ğŸ—£ï¸ANTI PALAVRÃƒOğŸ—£ï¸ ã€*\nVocÃª serÃ¡ banido do gp, Na proxima tenha Ã©tica ao falar!!`}, {quoted : info}).catch(e => {
conn.sendMessage(from, {text: `InFelizmente, nÃ£o sou um administrador, entt nÃ£o posso te banir!!`}, {quoted : info})
})       							
}, 0)
} else {
return reply(`VOCÃŠ PODE ${pushname} ğŸ˜‡`)
}
}
}
//=======================================\\

if(isAntiLink) { 
if(!isUrl(bady)) return 
if(type === 'stickerMessage') return 
if(type === 'audioMessage') return 
if(type === 'imageMessage') return   
if(budy.includes("https://") || (budy.includes(".net") || (budy.includes(".com" ) || (budy.includes("//s.kwai.app/") || (budy.includes("//vm.tiktok") || (budy.includes("www.") || (budy.includes("chat.whatsapp") || (budy.includes(".xml") || (budy.includes("youtube.com") || (budy.includes("//t.me/") || (budy.includes(".css")))))))))))) {
linkgpp = await conn.groupInviteCode(from)
if(budy.match(`${linkgpp}`)) return reply('Link do nosso grupo, nÃ£o irei remover.. ')  
if (!isGroup) return
if (isGroupAdmins) return reply(`*Vc Ã© admin do gp,fica tranquilo que nÃ£o irei te banir.*`)
setTimeout( () => {
}, 1100)
setTimeout( () => {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}
}
//========================================\\


//================(SIMIH-2)=================\\

if (isSimi2 && !isCmd && isGroup) {
if (type == 'conversation' || type == 'extendedTextMessage') {
if (info.key.fromMe) return
if (type == 'extendedTextMessage' && prefix.includes(info.message.extendedTextMessage.contextInfo.quotedMessage.conversation[0])) return
insert(type, info)
const sami = await response(budy)

if (sami) conn.sendMessage(from, {text: sami, thumbnail: fs.readFileSync('./logos/logo2.jpg', 'base64')}, {quoted: info});
}
}


 //===============(SIMIH-1)===============\\
    
if (isGroup && isSimi && budy != undefined) {
if(type == 'imageMessage') return 
if(type == 'audioMessage') return 
if(type == 'stickerMessage') return   
if(info.key.fromMe) return 
console.log(budy)
muehe = await simih(budy)
console.log(muehe)
reply(muehe)
}


//========================================\\

hora2 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

if (isCmd) {
reply(
`
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚|â€¢ Data: ${date} 
â”‚|â€¢ Hora: ${hora2}
â”‚|â€¢ Comando NÃ£o Registrado
â”‚|â€¢ Use: ${prefix}menu
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€
`)
}
//========================================\\

}
} catch (erro) {
console.log(erro)
}
})

conn.ev.on('creds.update', saveState)

}

startAle()